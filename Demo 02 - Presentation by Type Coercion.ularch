ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1>Presentation by type coercion</h1><p>With U-Larch, objects are presented using type coercion. In effect, this means that you can define&nbsp;a visual, interactive presentation for an object using a similar approach to that used to define a __str__ method.</p><h1>tl;dr</h1><p>Normal Python objects can be presented by embedding them within presentation descriptions, built from presentation types. They are automatically converted for you. If U-Larch is notified of a modification to an object's state, it will update it's&nbsp;in-browser representations automatically.</p><h1>Examples</h1><p>Recall that by default, an object is converted to a string using its type and its address:</p>
p13
sS'notebook'
p14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p15
g2
Ntp16
Rp17
(dp18
S'code'
p19
g0
(clarch.apps.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
Vclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000astr(Point(2.0, 5.0))
p24
sS'editable'
p25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp26
Rp27
(dp28
g12
V<p>We can customise this by defining a __str__ method:</p>
p29
sg14
g4
sbag0
(g15
g2
Ntp30
Rp31
(dp32
g19
g0
(g20
g2
Ntp33
Rp34
(dp35
g19
Vclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000a    def __str__(self):\u000a        return '[{0} {1}]'.format(self.x, self.y)\u000a        \u000astr(Point(2.0, 5.0))
p36
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp37
Rp38
(dp39
g12
V<p>This can now be used in more complex, composite objects. The __str__ method of the LineSegment class in turn converts the points to strings, and joins them together:</p>
p40
sg14
g4
sbag0
(g15
g2
Ntp41
Rp42
(dp43
g19
g0
(g20
g2
Ntp44
Rp45
(dp46
g19
Vclass LineSegment (object):\u000a    def __init__(self, a, b):\u000a        self.a, self.b = a, b\u000a        \u000a    def __str__(self):\u000a        return '{0} -> {1}'.format(self.a, self.b)\u000a\u000astr(LineSegment(Point(1.0, 2.0), Point(5.0, 8.0)))
p47
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp48
Rp49
(dp50
g12
V<p>Within U-Larch, the <code>__present__</code> method provides similar functionaltiy, except that you can use HTML markup to control the layout of your presentation. Back to our <code>Point</code> example:</p>
p51
sg14
g4
sbag0
(g15
g2
Ntp52
Rp53
(dp54
g19
g0
(g20
g2
Ntp55
Rp56
(dp57
g19
V# We need to import the Html presentation type, as __present__ must return presentation types.\u000afrom larch.pres.html import Html\u000a\u000aclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000a    def __str__(self):\u000a        return '[{0} {1}]'.format(self.x, self.y)\u000a    \u000a    def __present__(self, fragment):\u000a        # The [ and ] character surrounding the point co-ordinates.\u000a        open_bracket = '<span style="font-size: 3em">[</span>'\u000a        close_bracket = '<span style="font-size: 3em">]</span>'\u000a        # Arrange the X and Y co-ordinates vertically in a table, surround with the brackets\u000a        return Html(open_bracket, '<table style="border: 1px solid #e0e0e0; display: inline-table;"><tbody><tr><td>', self.x, '</td></tr><tr><td>', self.y, '</td></tr></tbody></table>', close_bracket)\u000a        \u000aPoint(2.0, 5.0)
p58
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp59
Rp60
(dp61
g12
V<p>Presentations are also composeable, as demonstrated with a visual version of the line segment example:</p>
p62
sg14
g4
sbag0
(g15
g2
Ntp63
Rp64
(dp65
g19
g0
(g20
g2
Ntp66
Rp67
(dp68
g19
Vclass LineSegment (object):\u000a    def __init__(self, a, b):\u000a        self.a, self.b = a, b\u000a        \u000a    def __str__(self):\u000a        return '{0} -> {1}'.format(self.a, self.b)\u000a    \u000a    def __present__(self, fragment):\u000a        return Html(self.a, '<span style="font-weight: bold;">-></span>', self.b)\u000a\u000aLineSegment(Point(1.0, 2.0), Point(5.0, 8.0))
p69
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp70
Rp71
(dp72
g12
V<p>Its not great, but you get the point. The viability of this approach is demonstrated by the fact that everything that you have seen in U-Larch so far is presented in this way; this notebook, its blocks, the U-Larch front page that displays the list of documents, and the console.</p><p>The content generated by a __present__ method does not have to be static; it can be interactive as well. In the next example, we will add controls, along with interactive updates:</p>
p73
sg14
g4
sbag0
(g15
g2
Ntp74
Rp75
(dp76
g19
g0
(g20
g2
Ntp77
Rp78
(dp79
g19
V# We must import the IncrementalValueMonitor class. They are used to inform U-Larch when the contents of an object has changed, so that U-Larch may schedule a refresh:\u000afrom larch.incremental import IncrementalValueMonitor\u000a\u000a# We would also like to use button conrols in this example:\u000afrom larch.controls import button\u000a\u000a\u000aclass Counter (object):\u000a    def __init__(self):\u000a        self.value = 0\u000a        # The incremental value monitor helps U-Larch monitor the state of this object\u000a        self.__incr = IncrementalValueMonitor()\u000a        \u000a        \u000a    def increment(self):\u000a        self.value += 1\u000a        # We have changed the state of this object; inform the monitor\u000a        self.__incr.on_changed()\u000a        \u000a    def decrement(self):\u000a        self.value -= 1\u000a        # We have changed the state of this object; inform the monitor\u000a        self.__incr.on_changed()\u000a        \u000a    def __present__(self, fragment):\u000a        # We are using the state of this object to construct the presentation; inform the incremental monitor of an access:\u000a        self.__incr.on_access()\u000a        \u000a        # Decrement button, label is '<', invoke the decrement method when clicked\u000a        dec_button = button.button('<', self.decrement)\u000a        # Increment button, label is '>', invoke the increment method when clicked\u000a        inc_button = button.button('>', self.increment)\u000a        \u000a        return Html(dec_button, '<span style="margin-left: 1em; margin-right: 1em">', self.value, '</span>', inc_button)\u000a\u000a\u000aCounter()
p80
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp81
Rp82
(dp83
g12
V<p>The buttons are arranged to surround the value. When they are clicked, the <code>decrement</code>&nbsp;or <code>increment</code>&nbsp;methods are invoked. These in turn modify the value and inform the incremental monitor. U-Larch maintains an association between the object (a Counter in this case) and its visual representation. When it is notified of a change to the object's state, it re-invokes&nbsp;<code>__present__</code>&nbsp;in order to build a new presentation of the counter, which is inserted into the DOM in place of the old one. As a consequence, you can now write interactive browser applications in Python.</p>
p84
sg14
g4
sbasb.