ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">Multiplayer Noughts and Crosses</h1><p>In this document we are going to develop a simple multiplayer game. You may have already seen that Ubiquitous Larch documents can be shared in real-time amount multiple users. We will now demonstrate that this can apply to your own Python objects as well; we are going to represent the state of our game using Python objects on the server. The Ubiquitous Larch presentation system will be used to present this state to each client/player. When considered on the context of the Model-View-Controller architecture, the model is stored on the server, with each client getting its own view.</p><p>When we receive user input, we are going to need to determine which player sent it. We will use a simple trick for this. On the server side, each active view gets its own 'dynamic page'. We can acquire a reference to this and used it to dertermine the source of our input. Note that this does mean that two different tabs in the same browser could count as the two players. We could go further, by getting the user from the 'dynamic page' and ensuring that the two players are different users. We will leave this as an exercise to the reader.</p><p>First, lets implement a single cell, that renders blank, nought or cross. It will also receive click events from the browser. It will be rendered using a 30x30 pixel&nbsp;SVG element.</p>
p13
sS'notebook'
p14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p15
g2
Ntp16
Rp17
(dp18
S'code'
p19
g0
(clarch.apps.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
V# We need to import the Html presentation type since we will need to to create output\u000a# that we wish to render\u000afrom larch.pres.html import Html\u000a# Live value is useful\u000afrom larch.live import LiveValue\u000a\u000aclass Cell (object):\u000a    def __init__(self, onclick=None, state=None):\u000a        """\u000a        onclick - callback invoked when the cell is clicked by the user; function(page)\u000a        state - the initial state of the cell, should be None, 'o' or 'x'\u000a        \u000a        To set the state in the future, use cell.state.value = new_state\u000a        """\u000a        self.__onclick = onclick\u000a        self.state = LiveValue(state)\u000a        \u000a    # Define a __present__ method: a visual version of __str__ or __repr__, that can\u000a    # create interactive, visual representations of an object\u000a    def __present__(self, fragment):\u000a        # Get the state\u000a        # Accessing a live value will register a computation dependency between the\u000a        # live value and this object's visual representation, so from now on, every time\u000a        # the value of self.state is modified, this object will have its visual\u000a        # representation automatically refreshed\u000a        state = self.state.value\u000a        \u000a        # Event handler function: passes the event to the callback, extracting the page\u000a        # from the fragment to pass through\u000a        def onclick(event_name, event_data):\u000a            if self.__onclick is not None:\u000a                self.__onclick(fragment.page)\u000a        \u000a        # A light grey rectangle to make up the background\u000a        background = '<rect x="0" y="0" width="30" height="30" fill="#ddd"/>'\u000a        \u000a        # Build the contents\u000a        if state == 'o':\u000a            contents = '<circle cx="15" cy="15" r="10" fill="transparent" stroke="#000" stroke-width="4"/>'\u000a        elif state == 'x':\u000a            contents = '<line x1="5" y1="5" x2="25" y2="25" fill="transparent" stroke="#000" stroke-width="4"/>' +\u005c\u000a                '<line x1="25" y1="5" x2="5" y2="25" fill="transparent" stroke="#000" stroke-width="4"/>'\u000a        else:\u000a            contents = ''\u000a        \u000a        # Place the background and the contents within an SVG element\u000a        # The SVG element has an onclick handler that invokes the client side JS\u000a        # function larch.postEvent to pass the event over to the server.\u000a        # The event is named xoclick.\u000a        # The with_event_handler chain method registers a server side event handler\u000a        # for xoclick events: the onclick function defined above\u000a        return Html('<svg width="30" height="30" onclick="javascript:larch.postEvent(this, \u005c'xoclick\u005c', null);">',\u000a                    background, contents, '</svg>').with_event_handler('xoclick', onclick)\u000a\u000a# A quick test: place three cells in a tuple\u000aCell(None),Cell(None,'o'),Cell(None,'x')
p24
sS'editable'
p25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp26
Rp27
(dp28
g12
V<p>Notice that the example cells above are displayed as elements within a tuple. Within Ubiquitous Larch, the standard Python types are rendered in the normal way. Using <code>__present__</code> methods we can define rich, interactive visual representations for objects, which will appear in-line alongside textual output.</p><h2>Game board</h2><p>Now, we will implement the game board.</p>
p29
sg14
g4
sbag0
(g15
g2
Ntp30
Rp31
(dp32
g19
g0
(g20
g2
Ntp33
Rp34
(dp35
g19
Vdef _page_username(page):\u000a    return page.user.username   if page.user is not None   else '<em>unknown</em>'\u000a\u000aclass GameBoard (object):\u000a    def __init__(self):\u000a        # A factory function to make cell click handlers; necessary to ensure that we can bind values\u000a        # for x and y; the positions of the cells. The handler calls self.__on_cell_click\u000a        def make_cell_click(x, y):\u000a            return lambda page: self.__on_cell_click(page, x, y)\u000a        # Make the cells\u000a        self.cells = [[Cell(make_cell_click(x, y), None)   for x in xrange(3)]   for y in xrange(3)]\u000a        # Live values containing references to the page instances and to the player whose turn it is\u000a        self.player1 = LiveValue()\u000a        self.player2 = LiveValue()\u000a        self.turn = LiveValue()\u000a        \u000a        \u000a    def __on_cell_click(self, page, x, y):\u000a        # The static_value attribute of a LiveValue gets you the same value as the value attribute.\u000a        # The difference is that a computational dependency will NOT be registered when using static_value\u000a        # So, use static_value in event handlers, but value in presentation methods (__present__)\u000a        p1 = self.player1.static_value\u000a        p2 = self.player2.static_value\u000a        cell = self.cells[y][x]\u000a        \u000a        if cell.state.static_value is None  and  p1 is not None  and  p2 is not None:\u000a            # Only repond if the cell has neither a 'x' or an 'o' and if the players have identified themselves\u000a            \u000a            if page is self.turn.static_value:\u000a                # Its our turn\u000a                cell.state.value = 'x'   if page is p1   else 'o'\u000a                self.turn.value = p2   if page is p1   else p1\u000a            	\u000a                \u000a        \u000a    def __present__(self, fragment):\u000a        # Getting the values of LiveValues within a __present__ method will register a computational\u000a        # dependency between the LiveValue and the objects presentation, as in the Cell class above\u000a        p1 = self.player1.value\u000a        p2 = self.player2.value\u000a        \u000a        # Blank presentation that we will build up\u000a        p = Html()\u000a        \u000a        # Identify players\u000a        if p1 is None:\u000a            # No player 1 yet; offer a clickable cell that will allow player 1 to identify themselves\u000a            def p1_cell_click(page):\u000a                self.player1.value = fragment.page\u000a            p.append('Player 1 click here: ', Cell(p1_cell_click, None), '<br>')\u000a        else:\u000a            # We have a player 1; display their username along with their side (crosses)\u000a            p.append('Player 1 is {0}'.format(_page_username(p1)), Cell(None, 'x'), '<br>')\u000a        \u000a            if p2 is None:\u000a                # No player 2 yet; offer a clickable cell that will allow player 2 to identify themselves\u000a                def p2_cell_click(page):\u000a                    self.player2.value = fragment.page\u000a                    # The game can start; player 1's turn\u000a                    self.turn.value = self.player1.static_value\u000a                p.append('Player 2 click here: ', Cell(p2_cell_click, None), '<br>')\u000a            else:\u000a                # We have a player 2; display their username along with their side (noughts)\u000a                p.append('Player 2 is {0}'.format(_page_username(p2)), Cell(None, 'o'), '<br>')\u000a        \u000a        # Display the game board as a table of cells)\u000a        p.append('<table>')\u000a        for row in self.cells:\u000a            p.append('<tr>')\u000a            for cell in row:\u000a                p.append('<td>', cell, '</td>')\u000a            p.append('</td>')\u000a        p.append('</table>')\u000a        \u000a        # If its our turn; say so\u000a        if fragment.page is self.turn.value:\u000a            p.append('Your turn')\u000a        \u000a        return p\u000a    \u000aGameBoard()
p36
sg25
I01
sbsg14
g4
sbasb.