ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">matplotlib Integration</h1><p><br></p><p>You will need to have <a data-cke-saved-href="http://matplotlib.org/" href="http://matplotlib.org/">matplotlib</a> installed in order for this notebook to run, otherwise you will see lots of exceptions instead of pretty pictures.</p><p><br></p><h2>Some notes about the matplotlib integration; its a little unusual (and a bit broken) right now</h2><p>Larch works in a functional manner, as you may have noticed. Values are displayed by evaluating expressions that create them. If a value displays itself visually, you will get a visual result.</p><p>Matplotlib is a little different; <code>show</code>, <code>imshow</code> and other such functions in a classical desktop based installation cause a window to pop up with your figure&nbsp;inside. Notebook environments -&nbsp;such as <a data-cke-saved-href="http://ipython.org/" href="http://ipython.org/">IPython</a> - display figures inline by catching the images generated by these functions and displaying them just beneath the code that creates them.</p><p>Larch is a little different. It hacks the <code>show</code>&nbsp;function to make it return a value; your figure. If <code>show</code> is the last thing you call in the block, you see your figure. If you call it within your own&nbsp;function, you need to make sure your function <em>returns</em> the value from show, otherwise your figure will not appear.</p><p>Why is Larch different? This will be explained at the bottom of this notebook.</p><p>Perhaps a little demo is in order:</p>
p13
sS'notebook'
p14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p15
g2
Ntp16
Rp17
(dp18
S'code'
p19
g0
(clarch.apps.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
Vimport matplotlib.pyplot as plt\u000afrom matplotlib.path import Path\u000aimport matplotlib.patches as patches\u000a\u000a# Taken from the matplotlib path tutorial:\u000averts = [\u000a    (0., 0.), # left, bottom\u000a    (0., 1.), # left, top\u000a    (1., 1.), # right, top\u000a    (1., 0.), # right, bottom\u000a    (0., 0.), # ignored\u000a    ]\u000a\u000acodes = [Path.MOVETO,\u000a         Path.LINETO,\u000a         Path.LINETO,\u000a         Path.LINETO,\u000a         Path.CLOSEPOLY,\u000a         ]\u000a\u000apath = Path(verts, codes)\u000a\u000afig = plt.figure()\u000aax = fig.add_subplot(111)\u000apatch = patches.PathPatch(path, facecolor='orange', lw=2)\u000aax.add_patch(patch)\u000aax.set_xlim(-2,2)\u000aax.set_ylim(-2,2)\u000a\u000a# The result of show() is what Larch will try to display, so this works just fine:\u000aplt.show()
p24
sS'editable'
p25
I01
sbsg14
g4
sbag0
(g15
g2
Ntp26
Rp27
(dp28
g19
g0
(g20
g2
Ntp29
Rp30
(dp31
g19
Vfig = plt.figure()\u000aax = fig.add_subplot(111)\u000apatch = patches.PathPatch(path, facecolor='orange', lw=2)\u000aax.add_patch(patch)\u000aax.set_xlim(-2,2)\u000aax.set_ylim(-2,2)\u000a\u000a# The result of show() is what Larch will try to display, so this works just fine:\u000aplt.show()\u000a\u000aprint 'Since a print statement is the last statement in the block, the result of calling plt.show() will be discarded (its not assigned to anything) and the figure will be missing.'
p32
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp33
Rp34
(dp35
g12
V<h2>Now, on to our demo:</h2><h2>Gravity simulation</h2><p>In this example, we are going to perform a simple gravity simulation, consisting of a gravity source at the origin and a body whose path we will trace. The body will be given and initial postion and velocity. The simulation will run for a given amount of time, using a specified time step. We will use numeric integration.<br></p><p>It is&nbsp;worth noting that the integration technique that we will be using is not particularly accurate, so please excuse the inaccurate&nbsp;results.</p>
p36
sg14
g4
sbag0
(g15
g2
Ntp37
Rp38
(dp39
g19
g0
(g20
g2
Ntp40
Rp41
(dp42
g19
Vimport math\u000a\u000a\u000a\u000adef simulate_gravity(initial_pos, initial_vel, dt, total_t):\u000a    """\u000a    Simulates the motion of a body acting under gravity emitted by a fixed body at the origin\u000a    \u000a    initial_pos - the initial position of the body as a 2-tuple\u000a    initial_vel - the initial velocity of the body as a 2-tuple\u000a    dt - the time delta per tick\u000a    total_t - the time over which to run the simulation\u000a    \u000a    returns - the path the body takes\u000a    """\u000a    path = [initial_pos[:]]\u000a    \u000a    pos = initial_pos[:]\u000a    vel = initial_vel[:]\u000a    t = 0.0\u000a    while t < total_t:\u000a        # Assume: both bodies have a mass of 1\u000a        \u000a        mag_p_sqr = pos[0]*pos[0]  +  pos[1]*pos[1]\u000a        mag_p = math.sqrt(mag_p_sqr)\u000a        \u000a        # Compute the magnitude of the acceleration\u000a        mag_a = 1.0 / mag_p_sqr\u000a        # Compute the direction of the acceleration\u000a        dir_a = -pos[0] / mag_p, -pos[1] / mag_p\u000a        # Acceleration vector is -p, normalized to length 1, multiplied by magnitude of A computed above\u000a        a = dir_a[0] * mag_a, dir_a[1] * mag_a\u000a        \u000a        pos[0] = pos[0]  +  vel[0] * dt  +  a[0] * dt*dt * 0.5\u000a        pos[1] = pos[1]  +  vel[1] * dt  +  a[1] * dt*dt * 0.5\u000a        \u000a        vel[0] += a[0] * dt\u000a        vel[1] += a[1] * dt\u000a        \u000a        path.append(pos[:])\u000a        \u000a        t += dt\u000a    \u000a    return path\u000a
p43
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp44
Rp45
(dp46
g12
V<p>Okay, thats our simulation function done. Now, lets try a sample plot:</p>
p47
sg14
g4
sbag0
(g15
g2
Ntp48
Rp49
(dp50
g19
g0
(g20
g2
Ntp51
Rp52
(dp53
g19
Vimport matplotlib.pyplot as plt\u000afrom matplotlib.path import Path\u000aimport matplotlib.patches as patches\u000a\u000a\u000adef plot_gravity_sim(initial_pos, initial_vel, dt, total_t):\u000a    verts = simulate_gravity(initial_pos, initial_vel, dt, total_t)\u000a    codes = [Path.MOVETO] + [Path.LINETO] * (len(verts)-1)\u000a    \u000a    \u000a    path = Path(verts, codes)\u000a    \u000a    fig = plt.figure()\u000a    ax = fig.add_subplot(111)\u000a    patch = patches.PathPatch(path, facecolor='none', lw=2)\u000a    ax.add_patch(patch)\u000a    ax.set_xlim(-20,20)\u000a    ax.set_ylim(-20,20)\u000a    \u000a    # In Larch, we must return the value of show:\u000a    return plt.show()\u000a\u000a\u000aplot_gravity_sim([0.0, 10.0], [0.3, 0.05], 1.0, 400.0)
p54
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp55
Rp56
(dp57
g12
V<p>Okay, that seems to work.</p><h2>Making it interactive</h2><p>Larch can create interactive plots too. Lets use some of the tricks we have learned in other notebooks to create some controls to modify our simulation:</p>
p58
sg14
g4
sbag0
(g15
g2
Ntp59
Rp60
(dp61
g19
g0
(g20
g2
Ntp62
Rp63
(dp64
g19
Vfrom larch.live import LiveValue, LiveFunction\u000afrom larch.controls.slider import live_slider\u000afrom larch.pres.html import Html\u000a\u000a\u000avel_x = LiveValue(0.3)\u000avel_y = LiveValue(0.05)\u000asim_time = LiveValue(400.0)\u000a\u000avel_x_slider = live_slider(vel_x, update_on_slide=True, min=-2.0, max=2.0, step=0.01, width=700)\u000avel_y_slider = live_slider(vel_y, update_on_slide=True, min=-2.0, max=2.0, step=0.01, width=700)\u000atime_slider = live_slider(sim_time, update_on_slide=True, min=1.0, max=1000.0, step=1.0, width=700)\u000a\u000a@LiveFunction\u000adef live_sim():\u000a    # Return the plot that we get back\u000a    return plot_gravity_sim([0.0, 10.0], [vel_x.value, vel_y.value], 1.0, sim_time.value)\u000a\u000aHtml(live_sim, '<br>',\u000a     '<table>',\u000a     '<tr><td>Velocity-X:</td><td>', vel_x, '&nbsp;&nbsp;</td><td>', vel_x_slider, '</td></tr>',\u000a     '<tr><td>Velocity-Y:</td><td>', vel_y, '&nbsp;&nbsp;</td><td>', vel_y_slider, '</td></tr>',\u000a     '<tr><td>Time:</td><td>', sim_time, '&nbsp;&nbsp;</td><td>', time_slider, '</td></tr>',\u000a     '</table>')
p65
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp66
Rp67
(dp68
g12
V<p>Unfortunately, its a bit flickery. This is a result of how interactive matplotlib figures&nbsp;are&nbsp;being generated and displayed. This will be addressed in the future.</p><h2>Why Larch uses matplotlib differently</h2><p>Larch hacks the <code>show</code> function to return the figure as a value so that you can incorporate it into your output any way you want. You can spatially arrange the figure along side other content, such as controls, other figures or anything else that you need. This is seen in the above example; the <code>Html</code> presentation type arranges the figure above the controls by just using the plot.</p><p>Additionally, it would be rather difficult to produce an interactive plot such as the one above without having <code>show</code> return a value, since this is needed for <code>LiveFunction</code> to work.</p><h2>In summary</h2><p>In this notebook, we have demonstrated Larch's matplotlib integration. It is mostly compatible with existing code, although not completely. Developing a compatibility mode is under consideration for the future. We have also demonstrated how we can use the existing interactive computation tools within Larch to create interactive matplotlib figures.</p>
p69
sg14
g4
sbasb.