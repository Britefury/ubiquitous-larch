ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">Visualising the Wealth and Health of Nations using data from Gapminder with d3.js</h1><p><br></p><p>Hans Rosling is well know for giving exciting and animated presentations in which he uses visualisation to chart the development of the world.</p><p>In this notebook, we will attempt to re-create one of his well known animated/interactive graphics, know as the&nbsp;<a data-cke-saved-href="http://www.gapminder.org/world/#$majorMode=chart$is;shi=t;ly=2003;lb=f;il=t;fs=11;al=30;stl=t;st=t;nsl=t;se=t$wst;tts=C$ts;sp=5.59290322580644;ti=2012$zpv;v=0$inc_x;mmid=XCOORDS;iid=phAwcNAVuyj1jiMAkmq1iMg;by=ind$inc_y;mmid=YCOORDS;iid=phAwcNAVuyj2tPLxKvvnNPA;by=ind$inc_s;uniValue=8.21;iid=phAwcNAVuyj0XOoBL_n5tAQ;by=ind$inc_c;uniValue=255;gid=CATID0;by=grp$map_x;scale=log;dataMin=283;dataMax=110808$map_y;scale=lin;dataMin=18;dataMax=87$map_s;sma=49;smi=2.65$cd;bd=0$inds=;modified=75" href="http://www.gapminder.org/world/#$majorMode=chart$is;shi=t;ly=2003;lb=f;il=t;fs=11;al=30;stl=t;st=t;nsl=t;se=t$wst;tts=C$ts;sp=5.59290322580644;ti=2012$zpv;v=0$inc_x;mmid=XCOORDS;iid=phAwcNAVuyj1jiMAkmq1iMg;by=ind$inc_y;mmid=YCOORDS;iid=phAwcNAVuyj2tPLxKvvnNPA;by=ind$inc_s;uniValue=8.21;iid=phAwcNAVuyj0XOoBL_n5tAQ;by=ind$inc_c;uniValue=255;gid=CATID0;by=grp$map_x;scale=log;dataMin=283;dataMax=110808$map_y;scale=lin;dataMin=18;dataMax=87$map_s;sma=49;smi=2.65$cd;bd=0$inds=;modified=75">Wealth &amp; Health of Nations</a>.</p><p>The interactive chart plots the progress of the economic and health development of countries over the span of over 200 years.</p><h2>Data</h2><p>First, we need some data to work with. Luckily, Rosling's organisation - <a data-cke-saved-href="http://www.gapminder.org/" href="http://www.gapminder.org/">Gapminder</a> - makes this data freely available in spreadsheet form as both Excel worksbooks and&nbsp;Google Docs spreadsheets. Luckily for us, the contents of a Google Docs spreadsheet can be easily acquired in the form of a CSV. Lets develop a function to acquire the data:</p>
p13
sS'notebook'
p14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p15
g2
Ntp16
Rp17
(dp18
S'code'
p19
g0
(clarch.apps.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
Vimport urllib2\u000aimport csv\u000aimport os\u000a\u000a\u000adef google_spreadsheet_as_csv_file(document_key):\u000a    request = urllib2.Request('https://docs.google.com/spreadsheet/pub?key={0}&output=csv'.format(document_key))\u000a    request.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.13 (KHTML, like Gecko) Chrome/24.0.1284.0 Safari/537.13')\u000a    opener = urllib2.build_opener()\u000a    \u000a    return opener.open(request)\u000a
p24
sS'editable'
p25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp26
Rp27
(dp28
g12
V<p>Downloading that data from Google can take a little while. We can save ourselves time by caching the data to a local file. Lets define a function that checks a cache file first, before downloading it from the web:</p>
p29
sg14
g4
sbag0
(g15
g2
Ntp30
Rp31
(dp32
g19
g0
(g20
g2
Ntp33
Rp34
(dp35
g19
Vdef cached_google_spreadsheet_as_csv_file(document_key, cache_path):\u000a    if not os.path.exists(cache_path):\u000a        google_fp = google_spreadsheet_as_csv_file(document_key)\u000a        data = google_fp.read()\u000a        with open(cache_path, 'wb') as f:\u000a            f.write(data)\u000a    \u000a    return open(cache_path, 'rb')
p36
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp37
Rp38
(dp39
g12
V<h2>Fetch the data</h2><p>The data that we will be using is <a data-cke-saved-href="http://spreadsheets.google.com/pub?key=phAwcNAVuyj1jiMAkmq1iMg&amp;gid=0" href="http://spreadsheets.google.com/pub?key=phAwcNAVuyj1jiMAkmq1iMg&amp;gid=0">Income per person (GDP/capita, PPP$ inflation-adjusted)</a>&nbsp;and <a data-cke-saved-href="https://docs.google.com/spreadsheet/pub?key=phAwcNAVuyj2tPLxKvvnNPA" href="https://docs.google.com/spreadsheet/pub?key=phAwcNAVuyj2tPLxKvvnNPA">Life expectancy (years)</a>.</p>
p40
sg14
g4
sbag0
(g15
g2
Ntp41
Rp42
(dp43
g19
g0
(g20
g2
Ntp44
Rp45
(dp46
g19
Vgdp_key = 'phAwcNAVuyj1jiMAkmq1iMg'\u000alife_ex_key = 'phAwcNAVuyj2tPLxKvvnNPA'\u000a\u000a# Ensure these two lines are uncommented to fetch the data from Google and comment the last two.\u000a\u000agdp_fp = cached_google_spreadsheet_as_csv_file(gdp_key, 'income.csv')\u000alife_ex_fp = cached_google_spreadsheet_as_csv_file(life_ex_key, 'life_ex.csv')
p47
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp48
Rp49
(dp50
g12
V<h2>A representation for time series data</h2><p>Each row in the spreadsheet contains time series data for a country, named in the first column. Some entries are missing. To account for this, we will interpolate missing entries, or relplicate the first and last available entries for missing entries at the beginning or end.</p><p>Now, we will implement a class for representing time series data. We will be doing the interpolation ourselves here. Normally, it would be a good idea to use the interpolators provided by <a data-cke-saved-href="http://www.scipy.org/" href="http://www.scipy.org/">SciPy</a>&nbsp;since they are fast and work well, but since I want to reduce the requirements (in terms of external libraries)&nbsp;of this notebook as much as possible, we will make do with our own here.</p>
p51
sg14
g4
sbag0
(g15
g2
Ntp52
Rp53
(dp54
g19
g0
(g20
g2
Ntp55
Rp56
(dp57
g19
Vclass TimeSeries (object):\u000a    def __init__(self, fp):\u000a        reader = csv.reader(fp)\u000a        # Get the first row; this contains the description of the data and the years\u000a        first_row = list(reader.next())\u000a        self.description = first_row[0]\u000a        self.time_points = [int(x)   for x in first_row[1:]]\u000a\u000a        # Subsequent rows are data; first column is the key, subsequent columns contain data or empty string        \u000a        self.data = {}\u000a        for row in reader:\u000a            key = row[0]\u000a            values = [float(x) if x != '' else None   for x in row[1:]]\u000a            # Interpolate in missing entries\u000a            values = TimeSeries.interpolate_missing_entries(self.time_points, values)\u000a            if values is not None:\u000a            	self.data[key] = values\u000a        fp.close()\u000a        \u000a        \u000a    def min_value(self):\u000a        """Get the minimum value"""\u000a        return min([min(xs)   for xs in self.data.values()])\u000a            \u000a    def max_value(self):\u000a        """Get the maximum value"""\u000a        return max([max(xs)   for xs in self.data.values()])\u000a    \u000a    \u000a    def __getitem__(self, value):\u000a        key, time = value\u000a        i = self.time_points.index(time)\u000a        return self.data[key][i]\u000a            \u000a            \u000a        \u000a    @staticmethod\u000a    def first_that(xs, f):\u000a        """\u000a        Find the first element int the sequence xs for which the function f returns True\u000a        """\u000a        for i, x in enumerate(xs):\u000a            if f(x):\u000a                return i, x\u000a        return None, None\u000a            \u000a    \u000a    @staticmethod\u000a    def interpolate_missing_entries(time_points, data):\u000a        """\u000a        Interpolate missing enties for the time series contains in data.\u000a        time_points lists the points in time that are used in the whole data set\u000a        """\u000a        \u000a        # Replicate the first non-empty data point towards the beginning as necessary\u000a        i, x = TimeSeries.first_that(data, lambda x: x is not None)\u000a        if i is None:\u000a            # No data in this row at all\u000a            return None\u000a        if i != 0:\u000a            data = [x] * i + data[i:]\u000a        \u000a        # Replicate the last non-empty data point towards the end as necessary\u000a        i, x = TimeSeries.first_that(list(reversed(data)), lambda x: x is not None)\u000a        if i != 0:\u000a            data = data[:-i] + [x] * i\u000a        \u000a        # Take a copy so we don't mutate the original\u000a        data = data[:]\u000a        \u000a        # Step through all data points except the last one\u000a        for i in xrange(len(data)-1):\u000a            # If the next data point is empty\u000a            if data[i+1] is None:\u000a                begin = i\u000a                end = None\u000a                # Find the closest non-empty point\u000a                for j in xrange(i+1, len(data)):\u000a                    if data[j] is not None:\u000a                        end = j\u000a                        break\u000a                if end is not None:\u000a                    range_size = time_points[end] - time_points[begin]\u000a                    # Fill in the gaps\u000a                    for p in xrange(begin + 1, end):\u000a                        t = (float(time_points[p]) - time_points[begin]) / range_size\u000a                        data[p] = data[begin] + (data[end] - data[begin]) * t\u000a        \u000a        return data\u000a
p58
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp59
Rp60
(dp61
g12
V<p>Now we read our data into our new time series form and determine the countries that are common to both:</p>
p62
sg14
g4
sbag0
(g15
g2
Ntp63
Rp64
(dp65
g19
g0
(g20
g2
Ntp66
Rp67
(dp68
g19
Vgdp = TimeSeries(gdp_fp)\u000alife_ex = TimeSeries(life_ex_fp)\u000a\u000a# Get the set of countries for which both time series have data\u000agdp_countries = set(gdp.data.keys())\u000alife_ex_countries = set(life_ex.data.keys())\u000agraph_countries = gdp_countries.intersection(life_ex_countries)\u000a# Sort them\u000agraph_countries = sorted(list(graph_countries))\u000a\u000a# Let's take a look:\u000agraph_countries
p69
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp70
Rp71
(dp72
g12
V<p>Now we determine the time interval for which we have data:</p>
p73
sg14
g4
sbag0
(g15
g2
Ntp74
Rp75
(dp76
g19
g0
(g20
g2
Ntp77
Rp78
(dp79
g19
V# Times for which we have data points in both series\u000agraph_times = set(gdp.time_points).intersection(life_ex.time_points)\u000a# Sort\u000agraph_times = sorted(list(graph_times))\u000a\u000a# Get the range\u000atime_start = min(graph_times)\u000atime_end = max(graph_times)\u000a\u000a# Take a look\u000atime_start, time_end
p80
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp81
Rp82
(dp83
g12
V<h2>Visualisation</h2><p>Now, we are ready to visualise the data. To do this, we will be enlisting the help of the wonderful <a data-cke-saved-href="http://d3js.org/" href="http://d3js.org/">d3.js</a> visualisation library.</p><p>The first step involves writing the Javascript code that will use d3 to create our chart.</p><p>Note that this example will use resources and live functions. Live values and live functions are explained in a documentation notebook of that name.</p>
p84
sg14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockSource
p85
g2
Ntp86
Rp87
(dp88
g19
g0
(clarch.apps.source_code
JSCode
p89
g2
Ntp90
Rp91
(dp92
g19
V/*\u000a * node - the DOM node to display our chart in (should be an SVG node)\u000a * data_rsc - the resource from which we obtain the data that we are going to display. It is sent over from the server, and allows\u000a * circleRadius - the radius of the circle used to display each data point\u000a * data_size - the number of data points\u000a * gdp_range - range of GDP values\u000a * gdp_ticks - the tick values to use for the GDP axis\u000a * life_ex_range - range of life expectancy values\u000a * width - width of the chart\u000a * height - height of the chart\u000a */\u000afunction initEconomicChart(node, data_rsc, circleRadius, data_size, gdp_range, gdp_ticks, life_ex_range, width, height) {\u000a    // First, generate an array of data elements of the form {gdp: min_gdp, life_ex: min_life_ex}\u000a    var data = d3.range(data_size).map(function() {return {gdp: gdp_range[0], life_ex: life_ex_range[0]};});\u000a    \u000a    // Some margin sizes\u000a    var TOP_MARGIN = 25, RIGHT_MARGIN = 15;\u000a    var BOTTOM_MARGIN = 45, LEFT_MARGIN = 45;\u000a    \u000a    \u000a    // Scales for our chart\u000a    // Map the range of GDP values to a logarithmic scale from left-most to right-most edges\u000a	var x = d3.scale.log()\u000a        .domain(gdp_range)\u000a        .range([LEFT_MARGIN, width - RIGHT_MARGIN]);\u000a    \u000a    // Map the range of life expectancy values to a linear scale from the bottom-most to top-most edges\u000a    var y = d3.scale.linear()\u000a        .domain(life_ex_range)\u000a        .rangeRound([height - BOTTOM_MARGIN, TOP_MARGIN]);\u000a    \u000a    // Axes\u000a    // Horizontal axis - use the X scale, ticks on the bottom, custom tick values, with a customised format to avoid SI notation\u000a    var xAxis = d3.svg.axis().scale(x).orient("bottom").tickValues(gdp_ticks).tickFormat(d3.format("d"));\u000a    // Vertical axis - use the Y scale, ticks on the left\u000a    var yAxis = d3.svg.axis().scale(y).orient("left");\u000a    \u000a\u000a	// Get a reference to the chart DOM node; passed as the first argument\u000a    var chart = d3.select(node);\u000a    \u000a    // Add the horizontal axis, positioned at the bottom\u000a    chart.append("g").attr("transform", "translate(0, " + (height-BOTTOM_MARGIN) + ")" ).call(xAxis);\u000a    // Add the vertical axis, positioned on the left\u000a    chart.append("g").attr("transform", "translate(" + LEFT_MARGIN + ", 0)" ).call(yAxis);\u000a    \u000a    // Add axis labels\u000a    chart.append("text")\u000a    	.attr("x", 0)\u000a    	.attr("y", 18)\u000a    	.text("Life expectancy")\u000a    	.attr("font-size", "14px")\u000a    	.attr("fill", "#666");\u000a\u000a    chart.append("text")\u000a    	.attr("x", width*0.5)\u000a    	.attr("y", height-4)\u000a    	.text("GDP/capita")\u000a    	.attr("font-size", "14px")\u000a    	.attr("fill", "#666");\u000a    \u000a    // Add the year in the background: 25% in from the left and bottom, 168px font size, light grey\u000a    chart.append("text")\u000a    	.attr("class", "year_label")\u000a    	.attr("x", width*0.25)\u000a    	.attr("y", height * 0.75)\u000a   		.text("year")\u000a    	.attr("font-size", "168px")\u000a    	.attr("fill", "#ddd");\u000a    \u000a	// Each data point is displayed as a circle. Use the x and y scale functions to map our data to diagram space\u000a    chart.selectAll("circle")\u000a        .data(data)\u000a      .enter().append("circle")\u000a        .attr("cx", function(d) { return x(d.gdp) - .5; })\u000a        .attr("cy", function(d) { return y(d.life_ex) - .5; })\u000a        .attr("r", circleRadius)\u000a    	.attr("fill", "#a00");\u000a    \u000a    // Resource objects allow us to access data from the server, normally via requesting the data from a URL.\u000a    // The server can also inform a client-side resource that its content has changed.\u000a    // The addListener method allows us to register a listener that will be invoked when this happens.\u000a    data_rsc.addListener(function() {\u000a        // Within our listener, we respond by fetching the JSON data from the server.\u000a        // This is done using an asynchronous request, that passes the data to a callback\u000a        data_rsc.fetchJSON(function(xs) {\u000a            // Redraw the diagram using our data\u000a            redraw(xs);\u000a        });\u000a    });\u000a\u000a	function redraw(dataFromRsc) {\u000a        // The values are accessible from the values attribute\u000a        // Get the circles within out chart and transition their positions (over a period of 50ms) to the desired locations\u000a        chart.selectAll("circle")\u000a            .data(dataFromRsc.values).transition().duration(50)\u000a            .attr("cx", function(d) { return x(d.gdp) - .5; })\u000a            .attr("cy", function(d) { return y(d.life_ex) - .5; });\u000a        // Update the text of our year label to the year attribute of the data we have received\u000a        chart.select(".year_label").text(dataFromRsc.year);\u000a	}\u000a\u000a	\u000a    // Get the initial data values and redraw\u000a	data_rsc.fetchJSON(function(xs) {\u000a        // Redraw\u000a        redraw(xs);\u000a    });\u000a}
p93
sg25
I01
sbsS'var_name'
p94
Veconomic_chart_js
p95
sg14
g4
sbag0
(g8
g2
Ntp96
Rp97
(dp98
g12
V<p>Now, we use Python code to:<br></p><ul><li>create a slider control that will allow you to control the year for which we are displaying data</li><li>create the chart</li><li>create a live resouce that will generate data for the chart to display</li></ul>
p99
sg14
g4
sbag0
(g15
g2
Ntp100
Rp101
(dp102
g19
g0
(g20
g2
Ntp103
Rp104
(dp105
g19
V# We need LiveValue and LiveFunction\u000afrom larch.live import LiveValue, LiveFunction\u000a# We want a slider control to allow the user to select the year\u000afrom larch.controls import slider\u000afrom larch.pres.html import Html\u000a# JsonLiveFnResource is a resource that takes a live function and converts it into a live resource that will schedule updates automatically\u000afrom larch.pres.resource import JsonLiveFnResource\u000a\u000a# Create the LiveValue that will contain the chosen year. Initialise to the earliest point for which we have data\u000ayear = LiveValue(time_start)\u000a# Create the slider control. update_on_slide means that it will continuously change the value in response to use actions, not just when the user lets go\u000ayear_slider = slider.live_slider(year, update_on_slide=True, min=time_start, max=time_end, step=1, width=800)\u000a# Place the slider to the right of a label.\u000ayear_ui = Html('<table><tr><td>Year: </td><td> </td><td>', year_slider, '</td></tr></table>')\u000a\u000a\u000a\u000a# This function computes the data that is sent to the client to be displayed\u000a#\u000a# How the function works\u000a# The function takes the currently chosen year, gets values for GDP and life expectency from the time series for each country for that year, and builds\u000a# a list of values that will position the circles in the chart.\u000a# Finally, this is returned in a dictionary that also has a field containing the year (so the label in the background will update)\u000a#\u000a# The decorators\u000a# LiveFunction - converts it to a live function. The fact that it accesses the value of the LiveValue in 'year' will be detected automatically. Each time\u000a# 		'year' is modified, this live function will notify the system that it too is out of date and needs a refresh\u000a# JsonLiveFnResource - constructs a live resource from the live function. It returns JSON data\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef data_for_chosen_year():\u000a    y = year.value\u000a    \u000a    values = []\u000a    for country in graph_countries:\u000a        values.append({'gdp': gdp[country, y], 'life_ex': life_ex[country, y]})\u000a        \u000a    return {'year': y, 'values': values}\u000a    \u000a    \u000a# The GDP tick values for the chart\u000agdp_ticks = [100,200,500, 1000,2000,5000, 10000,20000,50000, 100000]\u000a    \u000a    \u000a# The chart consists of an SVG element\u000adynamic_chart = Html('<svg class="chart" width="800" height="600"></svg>')\u000a\u000a# Initialise it with the Javascript function declared in the JS code block above (initEconomicChart). Most arguments are passed over from server to client directly.\u000a# The first argument is the name of the JS function. The client side function will receive the DOM element that we are initialising (the SVG element)\u000a# data_for_chosen_year - the resource at the server side will appear as its client side counterpart when it is passed to the Javascript function\u000a# circleRadius - 5 pixels\u000a# data_size - the size of our array\u000a# gdp_range - the range of GDP values\u000a# gdp_ticks - the tick positions on the chart\u000a# life_ex_range - the range of life expectency values. We use 0 for the minimum.\u000a# width, height - the size of the chart\u000adynamic_chart = dynamic_chart.js_function_call('initEconomicChart',\u000a                                               data_for_chosen_year,\u000a                                               5.0,\u000a                                               len(graph_countries),\u000a                                               [gdp.min_value(), gdp.max_value()],\u000a                                               gdp_ticks,\u000a                                               [0.0, life_ex.max_value()],\u000a                                               800,\u000a                                               600)\u000a\u000a# We need the JS declared above\u000adynamic_chart = dynamic_chart.use_js(source=economic_chart_js)\u000a\u000a# We need d3.js\u000adynamic_chart = dynamic_chart.use_js('/static/d3.v3.min.js')\u000a\u000a# Display, with the year slider just below\u000aHtml('<div>', dynamic_chart, '</div><div>', year_ui, '</div>')
p106
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp107
Rp108
(dp109
g12
V<p>Drag the slider just below the chart to change the year. You will see the GDP and life expectancy of the countries develop throughout the time period of 1800 to 2012.</p><h2>In Summary</h2><p>Within this notebook we have:</p><ul><li>Grabbed economic and health data over the web from a Google Docs spreadsheet</li><li>Used interpolation to fill in blank entries in the data</li><li>Visualised it using d3.js, with the interactivity provided by Python code</li></ul><p>The graphics are constructed by Javascript code using the d3.js library, while the interactivity is provided by Python code; each time you drag the slider, the value contained by the LiveValue Python object is updated, which in turn causes the&nbsp;data_for_chosen_year live function to trigger an update. This update request is sent to the client, which responds by getting the updated data and modifying the chart.</p>
p110
sg14
g4
sbasb.