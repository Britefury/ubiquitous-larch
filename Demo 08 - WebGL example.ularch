ccopy_reg
_reconstructor
p0
(clarch.apps.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.apps.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
sbag0
(g12
g2
Ntp19
Rp20
(dp21
g16
VExamples
p22
sg10
(lp23
g0
(clarch.apps.project.project_page
ProjectPage
p24
g2
Ntp25
Rp26
(dp27
S'data'
p28
g0
(clarch.apps.notebook.notebook
Notebook
p29
g2
Ntp30
Rp31
(dp32
S'blocks'
p33
(lp34
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p35
g2
Ntp36
Rp37
(dp38
S'text'
p39
V<h1>Torus examples</h1><p>First, import the uv mesh stuff:</p>
p40
sS'notebook'
p41
g31
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p42
g2
Ntp43
Rp44
(dp45
S'code'
p46
g0
(clarch.apps.source_code
PythonCode
p47
g2
Ntp48
Rp49
(dp50
g46
Vimport math\u000a\u000afrom larch.live import LiveFunction, LiveValue\u000afrom larch.pres.resource import JsonLiveFnResource\u000afrom larch.controls import slider\u000afrom larch.pres.html import Html\u000a\u000afrom larch import webglscene
p51
sS'editable'
p52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp53
Rp54
(dp55
g39
V<h1>Setting up the scene</h1><p>First, we set up a camera and the shader:</p>
p56
sg41
g31
sbag0
(g42
g2
Ntp57
Rp58
(dp59
g46
g0
(g47
g2
Ntp60
Rp61
(dp62
g46
Vcam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 12.0, 0.0, math.radians(30.0))\u000amaterial = webglscene.Material.plain_white\u000a
p63
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp64
Rp65
(dp66
g39
V<h1>Building a torus</h1><p>We need to build a torus in two ways; as a mesh, and as a UV mesh where the structure of the model is implicit. Mesh first (generate both vertices and indices):</p>
p67
sg41
g31
sbag0
(g42
g2
Ntp68
Rp69
(dp70
g46
g0
(g47
g2
Ntp71
Rp72
(dp73
g46
Vdef mesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices
p74
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp75
Rp76
(dp77
g39
V<p>Now for the UV mesh:</p>
p78
sg41
g31
sbag0
(g42
g2
Ntp79
Rp80
(dp81
g46
g0
(g47
g2
Ntp82
Rp83
(dp84
g46
Vdef uvmesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y * minor_radius\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices
p85
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp86
Rp87
(dp88
g39
V<h1>Example: mesh torus</h1>
p89
sg41
g31
sbag0
(g42
g2
Ntp90
Rp91
(dp92
g46
g0
(g47
g2
Ntp93
Rp94
(dp95
g46
Vmesh_verts, mesh_indices = mesh_torus(4.0, 32, 1.0, 16)\u000atorus_mesh = webglscene.MeshEntity(material, [['vertexPos', 3], ['vertexNrm', 3]], mesh_verts, [['triangles', mesh_indices]])\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [torus_mesh]))
p96
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp97
Rp98
(dp99
g39
V<p>Example: UV mesh torus</p>
p100
sg41
g31
sbag0
(g42
g2
Ntp101
Rp102
(dp103
g46
g0
(g47
g2
Ntp104
Rp105
(dp106
g46
Vuvmesh_vertpos = uvmesh_torus(4.0, 32, 1.0, 16)\u000a\u000auvsource = webglscene.UVMeshDataLiteral(16, 32, True, True, uvmesh_vertpos, [])\u000auvtorus = webglscene.UVMeshEntity(material, uvsource)\u000a\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvtorus]))
p107
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp108
Rp109
(dp110
g39
V<h1>Example: UV mesh torus as resource</h1>
p111
sg41
g31
sbag0
(g42
g2
Ntp112
Rp113
(dp114
g46
g0
(g47
g2
Ntp115
Rp116
(dp117
g46
Vmaj_rad = LiveValue(40)\u000amin_rad = LiveValue(10) \u000amaj_segs = LiveValue(32)\u000amin_segs = LiveValue(16) \u000a\u000a\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef torus_rsc():\u000a    vertices = uvmesh_torus(float(maj_rad.value)*0.1, maj_segs.value, float(min_rad.value)*0.1, min_segs.value)\u000a    return {\u000a            'uSegs': min_segs.value,\u000a            'vSegs': maj_segs.value,\u000a            'closedU': True,\u000a            'closedV': True,\u000a            'vertexPositions': vertices,\u000a            'vertexAttribsNamesSizesData': []\u000a            }\u000a\u000a\u000amaj_rad_slider = slider.live_slider(maj_rad, True)\u000amin_rad_slider = slider.live_slider(min_rad, True)\u000a\u000amaj_segs_slider = slider.live_slider(maj_segs, True)\u000amin_segs_slider = slider.live_slider(min_segs, True)\u000a\u000auvrsc = webglscene.UVMeshDataResource(torus_rsc)\u000auvrsctorus = webglscene.UVMeshEntity(material, uvrsc)\u000a\u000acanvas = webglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvrsctorus]))\u000aHtml(canvas, '<br>Major radius: ', maj_rad_slider, 'Major segments: ', maj_segs_slider, 'Minor radius: ', min_rad_slider, 'Minor segments: ', min_segs_slider)
p118
sg52
I01
sbsg41
g31
sbasbsg16
VTorusExamples
p119
sS'id'
p120
I1
sbasbag0
(g24
g2
Ntp121
Rp122
(dp123
g28
g0
(g29
g2
Ntp124
Rp125
(dp126
g33
(lp127
g0
(g35
g2
Ntp128
Rp129
(dp130
g39
V<h1>3D Plotting</h1><p>Imports first:</p>
p131
sg41
g125
sbag0
(g42
g2
Ntp132
Rp133
(dp134
g46
g0
(g47
g2
Ntp135
Rp136
(dp137
g46
Vimport math\u000a\u000afrom larch.live import LiveFunction, LiveValue\u000afrom larch.pres.resource import JsonLiveFnResource\u000afrom larch.controls import slider\u000afrom larch.pres.html import Html\u000a\u000afrom larch import webglscene
p138
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp139
Rp140
(dp141
g39
V<p>Now define 3D plotting function:</p>
p142
sg41
g125
sbag0
(g42
g2
Ntp143
Rp144
(dp145
g46
g0
(g47
g2
Ntp146
Rp147
(dp148
g46
Vdef plot3d_entity(data, width, depth, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a    \u000a    return uvmesh\u000a
p149
sg52
I01
sbsg41
g125
sbag0
(g42
g2
Ntp150
Rp151
(dp152
g46
g0
(g47
g2
Ntp153
Rp154
(dp155
g46
Vdef plot3d(data, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    uvmesh = plot3d_entity(data, width, depth, material=material)\u000a    \u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    focal_y = (min_y + max_y) * 0.5\u000a    \u000a    dim = max(width, depth, max_y - min_y)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, focal_y, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a\u000a
p156
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp157
Rp158
(dp159
g39
V<p>Live plotting:</p>
p160
sg41
g125
sbag0
(g42
g2
Ntp161
Rp162
(dp163
g46
g0
(g47
g2
Ntp164
Rp165
(dp166
g46
Vdef plot3d_live(data_live, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    @JsonLiveFnResource\u000a    @LiveFunction\u000a    def plot_rsc():\u000a        data = data_live.value\u000a        \u000a        v_segs = len(data)\u000a        u_segs = len(data[0])\u000a        \u000a        vertex_positions = []\u000a        vertex_attribs_names_sizes_data = []\u000a        if generate_tex_coords:\u000a            vertex_tex = []\u000a            vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a        \u000a        \u000a        delta_z = depth / v_segs\u000a        delta_x = width / u_segs\u000a        delta_s = 1.0 / u_segs\u000a        delta_t = 1.0 / v_segs\u000a    \u000a        z = depth * -0.5\u000a        t = 0.0\u000a        for row in data:\u000a            x = width * -0.5\u000a            s = 0.0\u000a            for col in row:\u000a                vertex_positions.extend([x, col, z])\u000a                if generate_tex_coords:\u000a                    vertex_tex.extend([s, t])\u000a                x += delta_x\u000a                s += delta_s\u000a            z += delta_z\u000a            t += delta_t\u000a\u000a        return {\u000a                'uSegs': u_segs,\u000a                'vSegs': v_segs,\u000a                'closedU': False,\u000a                'closedV': False,\u000a                'vertexPositions': vertex_positions,\u000a                'vertexAttribsNamesSizesData': vertex_attribs_names_sizes_data\u000a                }\u000a    \u000a    dim = max(width, depth)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataResource(plot_rsc)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a
p167
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp168
Rp169
(dp170
g39
V<p>Test (literal first):</p>
p171
sg41
g125
sbag0
(g42
g2
Ntp172
Rp173
(dp174
g46
g0
(g47
g2
Ntp175
Rp176
(dp177
g46
Vplot3d([[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)], 100.0, 100.0)
p178
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp179
Rp180
(dp181
g39
V<p>Now live data:</p>
p182
sg41
g125
sbag0
(g42
g2
Ntp183
Rp184
(dp185
g46
g0
(g47
g2
Ntp186
Rp187
(dp188
g46
Vu_scale = LiveValue(10)\u000av_scale = LiveValue(10) \u000a\u000a\u000a@LiveFunction\u000adef data():\u000a    us = u_scale.value*0.01\u000a    vs = v_scale.value*0.01\u000a    return [[float(((i-8)**2)*us+((j-8)**2))*vs   for i in xrange(16)] for j in xrange(16)]\u000a    #return [[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)]\u000a\u000au_slider = slider.live_slider(u_scale, True)\u000av_slider = slider.live_slider(v_scale, True)\u000a\u000acanvas = plot3d_live(data, 100.0, 100.0)\u000aHtml(canvas, '<br>U scale: ', u_slider, 'V scale: ', v_slider)
p189
sg52
I01
sbsg41
g125
sbasbsg16
Vplot3d
p190
sg120
I2
sbag0
(g24
g2
Ntp191
Rp192
(dp193
g28
g0
(g29
g2
Ntp194
Rp195
(dp196
g33
(lp197
g0
(g42
g2
Ntp198
Rp199
(dp200
g46
g0
(g47
g2
Ntp201
Rp202
(dp203
g46
Vimport math\u000aimport numpy as np\u000aimport random\u000a#from matplotlib import *\u000a\u000aimport plot3d\u000a\u000a\u000a\u000a\u000aclass PhilipsSpectrum (object):\u000a    def __init__(self, wave_height_factor, wind_speed, wind_vector, gravitational_constant, smoothness):\u000a        wind_inv_len = 1.0/math.sqrt(wind_vector[0]*wind_vector[0] + wind_vector[1]*wind_vector[1])\u000a        wind_vector[0] *= wind_inv_len\u000a        wind_vector[1] *= wind_inv_len\u000a        \u000a        self.wave_height_factor = wave_height_factor\u000a        self.wind_speed = wind_speed\u000a        self.wind_vector = wind_vector\u000a        self.largest_wave = wind_speed * wind_speed / gravitational_constant\u000a        self.gravitational_constant = gravitational_constant\u000a        self.smoothness = smoothness\u000a\u000a        \u000a\u000a    def philips_spectrum(self, kx, ky):\u000a        k_length = math.sqrt(kx*kx + ky*ky)\u000a        j = k_length / (2.0 * math.pi)\u000a        j2 = j * j\u000a        j4 = j2 * j2\u000a    \u000a        a = self.wave_height_factor\u000a        jl = j * self.largest_wave\u000a        e_ = -1.0 / (jl * jl)\u000a        b = math.exp(e_) / j4\u000a        knx = kx / k_length\u000a        kny = ky / k_length\u000a        k_dot_w = knx * self.wind_vector[0]  +  kny * self.wind_vector[1]\u000a        c = k_dot_w * k_dot_w\u000a        l = self.largest_wave * self.smoothness\u000a        d = math.exp(-j2 * l*l)\u000a\u000a        return a * b * c * d\u000a\u000a    \u000a    \u000a    def philips_matrix(self, size, resolution):\u000a        n_verts = resolution + 1\u000a        \u000a        k = np.linspace(0.0, 2.0 * math.pi * resolution / size, n_verts)\u000a        \u000a        inv_sqrt_2 = 1.0 / math.sqrt(2.0)\u000a        \u000a        philips = np.zeros((n_verts, n_verts))\u000a        \u000a        for y in xrange(n_verts):\u000a            for x in xrange(n_verts):\u000a                if x != 0  or  y != 0:\u000a                    p = self.philips_spectrum(k[x], k[y])\u000a                else:\u000a                    p = 0.0\u000a                q = inv_sqrt_2 * math.sqrt(p)\u000a                \u000a                philips[y,x] = q\u000a        \u000a        return philips\u000a    \u000a    \u000a    \u000a    \u000aclass Ocean (object):\u000a    def __init__(self, rnd_state, size, resolution, time_step):\u000a        \u000a        self.gravitational_constant = 1.0\u000a        self.size = size\u000a        self.resolution = resolution\u000a        self.n_verts = resolution + 1\u000a        self.time_step = time_step\u000a        \u000a        self.freq_rnd = rnd_state.randn(self.n_verts, self.n_verts) + rnd_state.randn(self.n_verts, self.n_verts) * 1j\u000a        self.freq = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.heights = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.single_step = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        self.step_table = []\u000a        \u000a        self.vertex_positions = []\u000a        \u000a        self.__update_step_table()\u000a        \u000a        \u000a    \u000a    def __update_step_table(self):\u000a        for y in xrange(self.n_verts):\u000a            for x in xrange(self.n_verts):\u000a                ux = x / self.size\u000a                uy = y / self.size\u000a                u = math.sqrt(ux*ux +uy*uy)\u000a                omega = math.sqrt(u * self.gravitational_constant) * self.time_step\u000a                c = math.cos(omega)\u000a                s = math.sin(omega)\u000a                self.single_step[y,x] = c + s *  1j\u000a                self.step_table = [self.single_step]\u000a        \u000a    \u000a    def apply_philips(self, spectrum):\u000a        philips = spectrum.philips_matrix(self.size, self.resolution)\u000a        \u000a        g_changed = self.gravitational_constant != spectrum.gravitational_constant\u000a        if g_changed:\u000a            self.gravitational_constant = spectrum.gravitational_constant\u000a            self.__update_step_table()\u000a        \u000a        \u000a        self.freq = self.freq_rnd * philips\u000a        \u000a                \u000a                \u000a                \u000a    def step(self, delta_t):\u000a        steps = int(delta_t / self.time_step)\u000a        if steps != 0:\u000a            ndx = steps - 1\u000a            try:\u000a                u = self.step_table[ndx]\u000a            except IndexError:\u000a                u = self.step_table[-1]\u000a                for i in xrange(len(self.step_table),ndx):\u000a                    u = u * self.single_step\u000a                    self.step_table.append(u)\u000a            \u000a            self.freq = self.freq * u\u000a        \u000a        \u000a    def update_heights(self):\u000a        spatial = np.fft.fft2(self.freq)\u000a        self.heights = np.array(spatial, dtype=float)\u000a        \u000a        self.vertex_positions = []\u000a        dx = self.size / self.resolution\u000a        z = 0.0\u000a        for j in xrange(self.n_verts):\u000a            x = 0.0\u000a            for i in xrange(self.n_verts):\u000a                self.vertex_positions.extend([x,self.heights[j,i],z])\u000a                x += dx\u000a            z += dx\u000a                \u000a                \u000a    \u000a    \u000a\u000a#o = Ocean(random.Random(123), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000a#o = Ocean(random.Random(223783), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000aphilips_spectrum = PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000ao = Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000ao.apply_philips(philips_spectrum)\u000a\u000ao.step(0.5)\u000ao.update_heights()\u000a#imshow(o.heights)\u000a\u000aplot3d.plot3d(o.heights, o.size, o.size)
p204
sg52
I01
sbsg41
g195
sbasbsg16
Vocean
p205
sg120
I3
sbag0
(g24
g2
Ntp206
Rp207
(dp208
g28
g0
(g29
g2
Ntp209
Rp210
(dp211
g33
(lp212
g0
(g42
g2
Ntp213
Rp214
(dp215
g46
g0
(g47
g2
Ntp216
Rp217
(dp218
g46
Vimport numpy as np\u000afrom scipy import interpolate\u000afrom larch import webglscene\u000afrom larch.pres.resource import ImageFromFile\u000aimport plot3d\u000a\u000a\u000a\u000adef make_harmonic(rnd, resolution, magnitude):\u000a    return rnd.randn(resolution+1, resolution+1) * magnitude\u000a\u000a\u000adef upscale_harmonic(h, resolution):\u000a    x = np.linspace(0.0, 1.0, len(h))\u000a    p = interpolate.interp2d(x, x, h, kind='cubic')\u000a    x_new = np.linspace(0.0, 1.0, resolution+1)\u000a    return p(x_new, x_new)\u000a    \u000a\u000a    \u000adef fractal_heightfield(rand_state, resolution, size, n_harmonics, top_h_res, magnitude, mag_scale):\u000a    # Generate harmonics\u000a    harmonics = []\u000a    h_res = top_h_res\u000a    h_mag = magnitude * mag_scale**(n_harmonics-1)\u000a    for i in xrange(n_harmonics):\u000a        h = make_harmonic(rand_state, h_res, h_mag)\u000a        h = upscale_harmonic(h, resolution)\u000a        harmonics.append(h)\u000a        h_res /= 2\u000a        h_mag = h_mag / mag_scale\u000a    \u000a    return sum(harmonics)\u000a    \u000a\u000a\u000ah = fractal_heightfield(np.random.RandomState(123), 128, 100.0, 4, 32, 5.0, 0.3)\u000amaterial=webglscene.Material.single_texture_2d(ImageFromFile('testimages/Sand.jpg'))\u000aplot3d.plot3d(h, len(h), len(h[0]), material=material, generate_tex_coords=True)
p219
sg52
I01
sbsg41
g210
sbasbsg16
Vfractal_landscape
p220
sg120
I4
sbag0
(g24
g2
Ntp221
Rp222
(dp223
g28
g0
(g29
g2
Ntp224
Rp225
(dp226
g33
(lp227
g0
(g35
g2
Ntp228
Rp229
(dp230
g39
V<h1>The final scene</h1><h2>Shaders</h2>
p231
sg41
g225
sbag0
(g35
g2
Ntp232
Rp233
(dp234
g39
V<h3>Surface shaders</h3><p>Ocean: plain</p>
p235
sg41
g225
sbag0
(clarch.apps.notebook.notebook
NotebookBlockSource
p236
g2
Ntp237
Rp238
(dp239
g46
g0
(clarch.apps.source_code
GLSLCode
p240
g2
Ntp241
Rp242
(dp243
g46
Vvoid surface(void) {\u000a	colour = vec3(dot(vertexNrm, vec3(0,1,0))) * vec3(0.0, 0.5, 1.0);\u000a}
p244
sg52
I01
sbsS'var_name'
p245
Vocean_plain_vert
p246
sg41
g225
sbag0
(g236
g2
Ntp247
Rp248
(dp249
g46
g0
(g240
g2
Ntp250
Rp251
(dp252
g46
Vvec4 surface(void) {\u000a	return vec4(colour, 1.0)*0.5+0.5;\u000a}
p253
sg52
I01
sbsg245
Vocean_plain_frag
p254
sg41
g225
sbag0
(g35
g2
Ntp255
Rp256
(dp257
g39
V<p>Ocean: fresnel</p>
p258
sg41
g225
sbag0
(g236
g2
Ntp259
Rp260
(dp261
g46
g0
(g240
g2
Ntp262
Rp263
(dp264
g46
Vconst float f0 = 0.05;\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avoid surface(void)\u000a{\u000a	vec3 worldSpaceEye = normalize( camPos.xyz - vertexPos.xyz );\u000a	\u000a	vec3 normal = dot( vertexNrm, worldSpaceEye )  >  0.0  ?  vertexNrm  :  -vertexNrm;\u000a	\u000a	float cosTheta = dot( worldSpaceEye, normal );\u000a	float omCosTheta = 1.0 - cosTheta;\u000a	float omCosTheta2 = omCosTheta * omCosTheta;\u000a	float omCosTheta4 = omCosTheta2 * omCosTheta2;\u000a	float omCosTheta5 = omCosTheta4 * omCosTheta;\u000a	frag_surf_water_f = f0  +  omCosTheta5 * ( 1.0 - f0 );\u000a	\u000a	float nDotE = dot( normal, worldSpaceEye );\u000a	vec3 projN = normal * nDotE;\u000a	frag_surf_water_refl = projN - ( worldSpaceEye - projN );\u000a}\u000a
p265
sg52
I01
sbsg245
Vocean_fresnel_vert
p266
sg41
g225
sbag0
(g236
g2
Ntp267
Rp268
(dp269
g46
g0
(g240
g2
Ntp270
Rp271
(dp272
g46
Vconst vec3 refrCol = vec3( vec3( 0.090, 0.341, 0.482 )*0.75 );\u000a\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	vec3 col = mix(refrCol, reflCol, frag_surf_water_f);\u000a\u000a	return vec4( col, 1.0 );\u000a}\u000a
p273
sg52
I01
sbsg245
Vocean_fresnel_frag
p274
sg41
g225
sbag0
(g236
g2
Ntp275
Rp276
(dp277
g46
g0
(g240
g2
Ntp278
Rp279
(dp280
g46
Vvarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	return vec4( reflCol * frag_surf_water_f, 1.0 - frag_surf_water_f );\u000a}\u000a
p281
sg52
I01
sbsg245
Vocean_transparent_fresnel_frag
p282
sg41
g225
sbag0
(g35
g2
Ntp283
Rp284
(dp285
g39
V<p>Terrain</p>
p286
sg41
g225
sbag0
(g236
g2
Ntp287
Rp288
(dp289
g46
g0
(g240
g2
Ntp290
Rp291
(dp292
g46
Vattribute vec2 vertexTex;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avoid surface(void) {\u000a	lighting = vec3(dot(vertexNrm, vec3(0,1,0)))*0.5+0.5;\u000a	texCoord = vertexTex;\u000a}
p293
sg52
I01
sbsg245
Vterrain_vert
p294
sg41
g225
sbag0
(g236
g2
Ntp295
Rp296
(dp297
g46
g0
(g240
g2
Ntp298
Rp299
(dp300
g46
Vuniform sampler2D sampler;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avec4 surface(void) {\u000a	return texture2D(sampler, texCoord) * vec4(lighting, 1.0);\u000a}\u000a
p301
sg52
I01
sbsg245
Vterrain_frag
p302
sg41
g225
sbag0
(g35
g2
Ntp303
Rp304
(dp305
g39
V<h3>Volume shaders</h3><p>Identity</p>
p306
sg41
g225
sbag0
(g236
g2
Ntp307
Rp308
(dp309
g46
g0
(g240
g2
Ntp310
Rp311
(dp312
g46
Vvoid volume(void)\u000a{\u000a}\u000a
p313
sg52
I01
sbsg245
Vvol_identity_vert
p314
sg41
g225
sbag0
(g236
g2
Ntp315
Rp316
(dp317
g46
g0
(g240
g2
Ntp318
Rp319
(dp320
g46
Vvec4 volume(vec4 surface)\u000a{\u000a	return surface;\u000a}\u000a
p321
sg52
I01
sbsg245
Vvol_identity_frag
p322
sg41
g225
sbag0
(g35
g2
Ntp323
Rp324
(dp325
g39
V<p>Oceanic fog</p>
p326
sg41
g225
sbag0
(g236
g2
Ntp327
Rp328
(dp329
g46
g0
(g240
g2
Ntp330
Rp331
(dp332
g46
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 1.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y > 0.0  &&  vertexPos.y > 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( camPos.y <= 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else if ( camPos.y > 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera above water, vertex below water\u000a			y1 = -vertexPos.y;\u000a			float fracBelowWater = y1 / ( camPos.y + y1 );\u000a			distance *= fracBelowWater;\u000a			y0 = 0.0;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p333
sg52
I01
sbsg245
Vvol_oceanfog_vert
p334
sg41
g225
sbag0
(g236
g2
Ntp335
Rp336
(dp337
g46
g0
(g240
g2
Ntp338
Rp339
(dp340
g46
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 2.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1,1,1)*(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y >= 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p341
sg52
I01
sbsg245
Vvol_oceanfog_forocean_vert
p342
sg41
g225
sbag0
(g236
g2
Ntp343
Rp344
(dp345
g46
g0
(g240
g2
Ntp346
Rp347
(dp348
g46
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, 1.0 );\u000a}
p349
sg52
I01
sbsg245
Vvol_oceanfog_frag
p350
sg41
g225
sbag0
(g236
g2
Ntp351
Rp352
(dp353
g46
g0
(g240
g2
Ntp354
Rp355
(dp356
g46
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	float transparency = frag_vol_oceanFog_transparency.a;\u000a	float alpha = surface.a * transparency;\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, alpha );\u000a}\u000a
p357
sg52
I01
sbsg245
Vvol_oceanfog_transparent_frag
p358
sg41
g225
sbag0
(g35
g2
Ntp359
Rp360
(dp361
g39
V<h3>Overall shader</h3>
p362
sg41
g225
sbag0
(g236
g2
Ntp363
Rp364
(dp365
g46
g0
(g240
g2
Ntp366
Rp367
(dp368
g46
Vprecision highp float;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000auniform vec4 camPos;\u000a\u000aattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000avarying vec3 colour;\u000a\u000avoid surface(void);\u000avoid volume(void);\u000a\u000a\u000avoid main(void)\u000a{\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a	\u000a	surface();\u000a	volume();\u000a}\u000a
p369
sg52
I01
sbsg245
Vmain_vert
p370
sg41
g225
sbag0
(g236
g2
Ntp371
Rp372
(dp373
g46
g0
(g240
g2
Ntp374
Rp375
(dp376
g46
Vprecision highp float;\u000a\u000auniform samplerCube sky;\u000a\u000avarying vec3 colour;\u000a\u000avec4 surface(void);\u000avec4 volume(vec4);\u000a\u000a\u000avoid main(void)\u000a{\u000a	vec4 surf = surface();\u000a	vec4 vol = volume( surf );\u000a	gl_FragColor = vol;\u000a}\u000a
p377
sg52
I01
sbsg245
Vmain_frag
p378
sg41
g225
sbag0
(g35
g2
Ntp379
Rp380
(dp381
g39
V<h2>Display the scene</h2>
p382
sg41
g225
sbag0
(g42
g2
Ntp383
Rp384
(dp385
g46
g0
(g47
g2
Ntp386
Rp387
(dp388
g46
Vimport math\u000a\u000aimport numpy as np\u000a\u000afrom larch import webglscene\u000afrom larch.pres.resource import ImageFromFile\u000a\u000a\u000aimport fractal_landscape\u000aimport ocean\u000aimport plot3d\u000a\u000a\u000a# Ocean function\u000adef make_ocean():\u000a    philips_spectrum = ocean.PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000a    o = ocean.Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000a    o.apply_philips(philips_spectrum)\u000a    \u000a    o.step(0.5)\u000a    o.update_heights()\u000a    \u000a    return o\u000a\u000a\u000a\u000a#\u000a# Sky textures\u000a#\u000a\u000asky_names = [\u000a             'testimages/skybox_east',\u000a             'testimages/skybox_west',\u000a             'testimages/skybox_down',\u000a             'testimages/skybox_up',\u000a             'testimages/skybox_south',\u000a             'testimages/skybox_north'\u000a             ]\u000a\u000asky_textures = [ImageFromFile('{0}.jpg'.format(n))   for n in sky_names]\u000a\u000a\u000a# Sky\u000asky = webglscene.Skybox(sky_textures)\u000a\u000a# Sky cubemap\u000asky_cube = webglscene.TextureCube(sky_textures)\u000a\u000a# Camera\u000acam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 150.0, 0.0, math.radians(30.0))\u000a\u000a\u000a\u000a#\u000a# Landscape material\u000a#\u000alandscape_material_plain = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_identity_vert], [main_frag + terrain_frag + vol_identity_frag]),\u000a    {'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000alandscape_material_oceanfog = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_oceanfog_vert], [main_frag + terrain_frag + vol_oceanfog_frag]),\u000a    {'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000a\u000a\u000alandscape_material = landscape_material_oceanfog\u000a\u000a\u000a# Landscape\u000alandscape_heightfield = fractal_landscape.fractal_heightfield(np.random.RandomState(2), 128, 100.0, 4, 32, 5.0, 0.3)\u000alandscape = plot3d.plot3d_entity(landscape_heightfield, 100.0, 100.0, material=landscape_material, generate_tex_coords=True)\u000a\u000a\u000a\u000a#\u000a# Ocean material\u000a#\u000a\u000aocean_material_plain = webglscene.Material(webglscene.Shader([main_vert + ocean_plain_vert + vol_identity_vert], [main_frag + ocean_plain_frag + vol_identity_frag]))\u000aocean_material_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_fresnel_frag + vol_identity_frag]),\u000a        {'sky': sky_cube})\u000aocean_material_trans_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_transparent_fresnel_frag + vol_identity_frag]),\u000a        {'sky': sky_cube}, use_blending=True)\u000aocean_material_trans_fresnel_oceanfog = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_oceanfog_forocean_vert], [main_frag + ocean_transparent_fresnel_frag + vol_oceanfog_transparent_frag]),\u000a        {'sky': sky_cube}, use_blending=True)\u000a\u000aocean_material = ocean_material_trans_fresnel_oceanfog\u000a\u000a\u000a# Ocean\u000aoc = make_ocean()\u000aoc3d = plot3d.plot3d_entity(oc.heights, oc.size, oc.size, material=ocean_material)\u000a\u000a\u000a# Scene on canvas\u000awebglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape, oc3d]))\u000a#webglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape]))\u000a
p389
sg52
I01
sbsg41
g225
sbasbsg16
VCool_Demo
p390
sg120
I5
sbasb.