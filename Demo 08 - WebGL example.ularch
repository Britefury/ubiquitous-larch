ccopy_reg
_reconstructor
p0
(clarch.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
g0
(clarch.project.project_page
ProjectPage
p19
g2
Ntp20
Rp21
(dp22
S'data'
p23
g0
(clarch.worksheet.worksheet
Worksheet
p24
g2
Ntp25
Rp26
(dp27
S'blocks'
p28
(lp29
g0
(clarch.worksheet.worksheet
WorksheetBlockText
p30
g2
Ntp31
Rp32
(dp33
S'worksheet'
p34
g26
sS'text'
p35
V<h1>WebGL Canvas</h1><p>First, we implement the Javascript code that renders objects using WebGL:</p>
p36
sbag0
(clarch.worksheet.worksheet
WorksheetBlockSource
p37
g2
Ntp38
Rp39
(dp40
g34
g26
sS'code'
p41
g0
(clarch.source_code
JSCode
p42
g2
Ntp43
Rp44
(dp45
g41
Vfunction degToRad(deg) {\u000a    return deg * (Math.PI/180.0);\u000a}\u000a\u000a\u000afunction GLCanvas(canvas) {\u000a    var glc = {};\u000a    glc.canvas = canvas;\u000a    glc.gl = null;\u000a    \u000a    try {\u000a        glc.gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");\u000a    }\u000a    catch (e) {\u000a        console.log("Caught " + e + " when initialising webgl");\u000a    }\u000a    \u000a    glc.redraw = function() {\u000a        glc.draw(glc);\u000a    }\u000a    \u000a    return glc;\u000a}\u000a\u000a\u000a\u000afunction ShaderCanvas(canvas, vsSource, fsSource) {\u000a    var glc = GLCanvas(canvas);\u000a\u000a    var gl = glc.gl;\u000a    \u000a    if (gl) {\u000a    	//\u000a        // SHADERS\u000a        //\u000a        \u000a        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\u000a        gl.shaderSource(vertexShader, vsSource);\u000a        gl.compileShader(vertexShader);\u000a        \u000a        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\u000a            alert("Vertex shader compile failed " + gl.getShaderInfoLog(vertexShader));\u000a        }\u000a        \u000a        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\u000a        gl.shaderSource(fragmentShader, fsSource);\u000a        gl.compileShader(fragmentShader);\u000a        \u000a        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\u000a            alert("Fragment shader compile failed " + gl.getShaderInfoLog(fragmentShader));\u000a        }\u000a        \u000a        var shaderProgram = gl.createProgram();\u000a        gl.attachShader(shaderProgram, vertexShader);\u000a        gl.attachShader(shaderProgram, fragmentShader);\u000a        gl.linkProgram(shaderProgram);\u000a        \u000a        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\u000a            alert("Unable to link the shader program.");\u000a        }        \u000a        \u000a        gl.useProgram(shaderProgram);\u000a        glc.shaderProgram = shaderProgram;\u000a    }\u000a    \u000a    return glc;\u000a}\u000a\u000a\u000afunction TurntableCanvas(canvas, vsSource, fsSource, fovY, nearFrac, farFrac, focalPoint, orbitalRadius, azimuth, altitude) {\u000a    var glc = ShaderCanvas(canvas, vsSource, fsSource);\u000a    \u000a    \u000a    glc.fovY = fovY;\u000a    glc.aspectRatio = canvas.width/canvas.height;\u000a    glc.nearFrac = nearFrac;\u000a    glc.farFrac = farFrac;\u000a    glc.focalPoint = focalPoint;\u000a    glc.orbitalRadius = orbitalRadius;\u000a    glc.azimuth = azimuth;\u000a    glc.altitude = altitude;\u000a    glc._navFunction = null;\u000a    glc._navPos = null;\u000a    \u000a    canvas.onmousedown = function(evt) {\u000a        if (evt.altKey) {\u000a            glc._navFunction = evt.button;\u000a            glc._navPos = [evt.offsetX, evt.offsetY];\u000a            return false;\u000a        }\u000a        else {\u000a            return true;\u000a        }\u000a        \u000a    }\u000a        \u000a    canvas.onmouseup = function(evt) {\u000a        glc._navFunction = null;\u000a    }\u000a            \u000a    canvas.onmousemove = function(evt) {\u000a        if (glc._navFunction !== null) {\u000a            var dx = evt.offsetX - glc._navPos[0];\u000a            var dy = glc._navPos[1] - evt.offsetY;\u000a            \u000a            if (glc._navFunction === 0) {\u000a                glc.rotate(-dx * 0.01, -dy * 0.01);\u000a                glc.redraw();\u000a            }\u000a            else if (glc._navFunction === 1) {\u000a            } \u000a            else if (glc._navFunction === 2) {\u000a                glc.zoom(Math.pow(Math.pow(2.0,0.005), -dx));\u000a                glc.redraw();\u000a            }\u000a            glc._navPos = [evt.offsetX, evt.offsetY];\u000a        }\u000a    }\u000a    \u000a    glc.apply = function(gl) {\u000a        var near = glc.nearFrac * glc.orbitalRadius;\u000a        var far = glc.farFrac * glc.orbitalRadius;\u000a        \u000a        var projectionMatrix = mat4.create();\u000a        mat4.perspective(projectionMatrix, fovY, glc.aspectRatio, near, far);\u000a        \u000a        // Camera matrix\u000a        var cameraMatrix = glc._createWorldToCameraMatrix();\u000a        //cameraMatrix = mat4.create();\u000a        //mat4.lookAt(cameraMatrix, [0.0, 6.0*Math.sin(degToRad(30.0)), -6.0*Math.cos(degToRad(30.0))], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]); \u000a        \u000a        \u000a        var pUniform = gl.getUniformLocation(glc.shaderProgram, "projectionMatrix");\u000a        gl.uniformMatrix4fv(pUniform, false, new Float32Array(projectionMatrix));\u000a        \u000a        var mvUniform = gl.getUniformLocation(glc.shaderProgram, "cameraMatrix");\u000a        gl.uniformMatrix4fv(mvUniform, false, new Float32Array(cameraMatrix));\u000a    }\u000a        \u000a    glc._createWorldToCameraMatrix = function() {\u000a        var cameraMatrix = mat4.create();\u000a	    var invPos = vec3.create();\u000a        vec3.negate(invPos, glc.focalPoint);\u000a        \u000a        // Move the world and camera so that the camera lies at the origin\u000a        mat4.translate(cameraMatrix, cameraMatrix, [0.0, 0.0, -glc.orbitalRadius]);\u000a        \u000a        // Rotate the world so that the camera lies on the forward axis\u000a        mat4.rotateY(cameraMatrix, cameraMatrix, -glc.azimuth);\u000a        \u000a        // Rotate the world and camera so that the camera rests on the XZ plane\u000a        mat4.rotateX(cameraMatrix, cameraMatrix, glc.altitude);\u000a        \u000a        // Move the focal point to the centre of the world\u000a        mat4.translate(cameraMatrix, cameraMatrix, invPos);\u000a\u000a        return cameraMatrix;\u000a    }\u000a        \u000a    glc._createCameraToWorldRotationMatrix = function() {\u000a        // Inverse of _createWorldToCameraMatrix(), but rotations only\u000a        var cameraMatrix = mat3.create();\u000a        \u000a        mat3.rotateY(cameraMatrix, cameraMatrix, glc.azimuth);\u000a        mat3.rotateX(cameraMatrix, cameraMatrix, -glc.altitude);\u000a        \u000a        return cameraMatrix;\u000a    }        \u000a        \u000a        \u000a    glc.translate = function(translation) {\u000a        vec3.add(glc.focalPoint, glc.focalPoint, translation);\u000a    }\u000a        \u000a    glc.zoom = function(zoomFactor) {\u000a        glc.orbitalRadius *= zoomFactor;\u000a    }\u000a           \u000a    glc.rotate = function(azimuth, altitude) {\u000a        glc.azimuth = (this.azimuth + azimuth) % Math.PI;\u000a        glc.altitude += altitude;\u000a        glc.altitude = Math.min(Math.max(glc.altitude, -Math.PI*0.5), Math.PI*0.5);\u000a    }\u000a    \u000a    glc.pan = function(translationInCameraSpace) {\u000a        var camRot = glc._createCameraToWorldRotationMatrix();\u000a        var translationInWorldSpace = vec3.create();\u000a        vec3.transformMat3(translationInWorldSpace, translationInCameraSpace, camRot);\u000a        \u000a		glc.translate(translationInWorldSpace);\u000a    }        \u000a    \u000a    return glc;\u000a}\u000a\u000a\u000a\u000afunction LiteralMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, indexBufferModesData) {\u000a    var glc = TurntableCanvas(canvas, vsSource, fsSource, fovY, 0.01, 100.0, focalPoint, orbitalRadius, degToRad(0.0), degToRad(30.0));\u000a    \u000a	var gl = glc.gl;\u000a    \u000a\u000a    gl.useProgram(glc.shaderProgram);\u000a        \u000a\u000a    //\u000a    // CREATE VERTICES BUFFER\u000a    //\u000a    \u000a    var verticesBuffer = gl.createBuffer();\u000a    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\u000a    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\u000a    glc.verticesBuffer = verticesBuffer;\u000a    \u000a    \u000a    \u000a    //\u000a    // GET ATTRIBUTE LOCATIONS\u000a	//\u000a    \u000a    var attribLocations = [];\u000a    var attribSizes = [];\u000a    var attribStride = 0;\u000a    for (var i = 0; i < vertexAttribNamesSizes.length; i++) {\u000a        var loc = gl.getAttribLocation(glc.shaderProgram, vertexAttribNamesSizes[i][0]);\u000a        gl.enableVertexAttribArray(loc);\u000a        \u000a        attribLocations.push(loc);\u000a        var sz = vertexAttribNamesSizes[i][1];\u000a        attribSizes.push(sz);\u000a        attribStride += sz;\u000a    }\u000a    glc.attribLocations = attribLocations;\u000a    glc.attribSizes = attribSizes;\u000a    glc.attribStride = attribStride;\u000a    \u000a    \u000a    \u000a    //\u000a    // CREATE INDICES BUFFER\u000a    //\u000a    \u000a    var indexBuffers = [];\u000a    var indexBufferModes = [];\u000a    var indexBufferSizes = [];\u000a    \u000a    var _modeNameToMode = {\u000a        points: gl.POINTS,\u000a        line_strip: gl.LINE_STRIP,\u000a        line_loop: gl.LINE_LOOP,\u000a        lines: gl.LINES,\u000a        triangle_strip: gl.TRIANGLE_STRIP,\u000a        triangle_fan: gl.TRIANGLE_FAN,\u000a        triangles: gl.TRIANGLES,\u000a    };\u000a    \u000a    for (var i = 0; i < indexBufferModesData.length; i++) {\u000a        var mode = _modeNameToMode[indexBufferModesData[i][0]];\u000a        var indices = indexBufferModesData[i][1];\u000a        var indicesBuffer = gl.createBuffer();\u000a        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\u000a        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\u000a        indexBuffers.push(indicesBuffer);\u000a        indexBufferModes.push(mode);\u000a        indexBufferSizes.push(indices.length);\u000a    }\u000a    glc.indexBuffers = indexBuffers;\u000a    glc.indexBufferModes = indexBufferModes;\u000a    glc.indexBufferSizes = indexBufferSizes;\u000a    \u000a    \u000a       \u000a    \u000a    function draw(glc) {\u000a        var gl = glc.gl;\u000a        \u000a        gl.clearColor(0.0, 0.0, 0.0, 1.0);\u000a        gl.enable(gl.DEPTH_TEST);\u000a        gl.depthFunc(gl.LEQUAL);\u000a        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\u000a        \u000a        gl.useProgram(glc.shaderProgram);\u000a        \u000a        // Apply camera\u000a        glc.apply(gl);\u000a\u000a        \u000a        //\u000a        // OBJECT\u000a        //\u000a        \u000a        gl.bindBuffer(gl.ARRAY_BUFFER, glc.verticesBuffer);\u000a        var offset = 0;\u000a        for (var i = 0; i < glc.attribLocations.length; i++) {\u000a            gl.vertexAttribPointer(glc.attribLocations[i], glc.attribSizes[i], gl.FLOAT, false, glc.attribStride*4, offset*4);\u000a            offset += glc.attribSizes[i];\u000a        }\u000a        \u000a        for (var i = 0; i < glc.indexBuffers.length; i++) {\u000a	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glc.indexBuffers[i]);\u000a	        gl.drawElements(glc.indexBufferModes[i], glc.indexBufferSizes[i], gl.UNSIGNED_SHORT, 0);\u000a        }\u000a		        \u000a    }\u000a    \u000a    glc.draw = draw;\u000a    \u000a    glc.redraw();\u000a    \u000a    return glc;\u000a}\u000a\u000a\u000a\u000a\u000a\u000a\u000afunction UVMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius) {\u000a    var glc = TurntableCanvas(canvas, vsSource, fsSource, fovY, 0.01, 100.0, focalPoint, orbitalRadius, degToRad(0.0), degToRad(30.0));\u000a	var gl = glc.gl;\u000a    \u000a\u000a    gl.useProgram(glc.shaderProgram);\u000a\u000a    \u000a    \u000a    glc.verticesBuffer = gl.createBuffer();\u000a    glc.indexBuffer = gl.createBuffer();\u000a    \u000a    \u000a    \u000a    function refreshUVMesh(uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData) {\u000a        //\u000a        // Convert incoming arrays to Float32Arrays\u000a        // Compute total vertex size\u000a        //\u000a        vertexPositions = new Float32Array(vertexPositions);\u000a        var vertexSize = 6;		// Account for position and normal\u000a        for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a            vertexSize += vertexAttribsNamesSizesData[i][1];\u000a            vertexAttribsNamesSizesData[i][2] = new Float32Array(vertexAttribsNamesSizesData[i][2]);\u000a        }\u000a        \u000a        \u000a        \u000a        //\u000a        // ASSEMBLE VERTEX ARRAY\u000a        //\u000a            \u000a        var bufferSize = vertexSize * uSegs * vSegs;\u000a        var vertices = new Float32Array(bufferSize);\u000a    \u000a        for (var y = 0; y < vSegs; y++) {\u000a            for (var x = 0; x < uSegs; x++) {\u000a                // Vertex position\u000a                var ndx = x+y*uSegs;\u000a                var pos = [vertexPositions[ndx*3], vertexPositions[ndx*3+1], vertexPositions[ndx*3+2]];\u000a    \u000a                // Get adjacent vertices and compute normal\u000a                var ixp = x > 0  ?  x - 1  :  (closedU ? uSegs - 1 : 0);			// X-prev\u000a                var ixn = x < uSegs - 1  ?  x + 1  :  (closedU ? 0 : uSegs - 1);	// X-next\u000a                var iyp = y > 0  ?  y - 1  :  (closedV ? vSegs - 1 : 0);			// Y-prev\u000a                var iyn = y < vSegs - 1  ?  y + 1  :  (closedV ? 0 : vSegs - 1);	// Y-next\u000a                var vxp = [vertexPositions[(ixp+y*uSegs)*3], vertexPositions[(ixp+y*uSegs)*3+1], vertexPositions[(ixp+y*uSegs)*3+2]];\u000a                var vxn = [vertexPositions[(ixn+y*uSegs)*3], vertexPositions[(ixn+y*uSegs)*3+1], vertexPositions[(ixn+y*uSegs)*3+2]];\u000a                var vyp = [vertexPositions[(x+iyp*uSegs)*3], vertexPositions[(x+iyp*uSegs)*3+1], vertexPositions[(x+iyp*uSegs)*3+2]];\u000a                var vyn = [vertexPositions[(x+iyn*uSegs)*3], vertexPositions[(x+iyn*uSegs)*3+1], vertexPositions[(x+iyn*uSegs)*3+2]];\u000a                var u = [vxn[0] - vxp[0], vxn[1] - vxp[1], vxn[2] - vxp[2]];\u000a                var v = [vyn[0] - vyp[0], vyn[1] - vyp[1], vyn[2] - vyp[2]];\u000a                var n = [u[1] * v[2] - u[2] * v[1],   u[2] * v[0] - u[0] * v[2],   u[0] * v[1] - u[1] * v[0]];\u000a                var nlen = Math.sqrt(n[0]*n[0]  +  n[1]*n[1]  +  n[2]*n[2]);\u000a                var invl = nlen == 0.0  ?  1.0  :  1.0 / nlen;\u000a                n = [n[0]*invl, n[1]*invl, n[2]*invl];\u000a                \u000a                // Add to array\u000a                var offset = ndx*vertexSize;\u000a                vertices[offset] = pos[0];\u000a                vertices[offset+1] = pos[1];\u000a                vertices[offset+2] = pos[2];\u000a                vertices[offset+3] = n[0];\u000a                vertices[offset+4] = n[1];\u000a                vertices[offset+5] = n[2];\u000a                \u000a                offset += 6;\u000a                // Deal with remaining attributes\u000a                for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a                    var sz = vertexAttribsNamesSizesData[i][1];\u000a                    for (var j = 0; j < sz; j++) {\u000a                        vertices[offset+j] = vertexAttribsNamesSizesData[i][2][ndx*sz+j];\u000a                    }\u000a                    offset += sz;\u000a                }\u000a            }\u000a        }\u000a            \u000a    \u000a        //\u000a        // CREATE VERTICES BUFFER\u000a        //\u000a        \u000a        gl.bindBuffer(gl.ARRAY_BUFFER, glc.verticesBuffer);\u000a        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\u000a        \u000a        \u000a        \u000a        //\u000a        // GET ATTRIBUTE LOCATIONS\u000a        //\u000a        \u000a        var attribLocations = [];\u000a        var attribSizes = [];\u000a            \u000a        // Handle position and normal first\u000a        \u000a        var vertexPosLoc = gl.getAttribLocation(glc.shaderProgram, "vertexPos");\u000a        gl.enableVertexAttribArray(vertexPosLoc);\u000a        attribLocations.push(vertexPosLoc);\u000a        attribSizes.push(3);\u000a        \u000a        var vertexNrmLoc = gl.getAttribLocation(glc.shaderProgram, "vertexNrm");\u000a        gl.enableVertexAttribArray(vertexNrmLoc);\u000a        attribLocations.push(vertexNrmLoc);\u000a        attribSizes.push(3);\u000a        \u000a        var attribStride = 6;\u000a            \u000a        // Now handle remaining attributes\u000a        \u000a        for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a            var loc = gl.getAttribLocation(glc.shaderProgram, vertexAttribsNamesSizesData[i][0]);\u000a            gl.enableVertexAttribArray(loc);\u000a            \u000a            attribLocations.push(loc);\u000a            var sz = vertexAttribsNamesSizesData[i][1];\u000a            attribSizes.push(sz);\u000a            attribStride += sz;\u000a        }\u000a        glc.attribLocations = attribLocations;\u000a        glc.attribSizes = attribSizes;\u000a        glc.attribStride = attribStride;\u000a        \u000a        \u000a        \u000a        //\u000a        // CREATE INDICES BUFFER\u000a        //\u000a        \u000a        var numRows = closedV  ?  vSegs  :  vSegs - 1;\u000a        var numColumns = closedU  ?  uSegs  :  uSegs - 1;\u000a        var indices = new Uint16Array(numRows*numColumns*6);\u000a        \u000a        var ndx = 0;\u000a        for (var y = 0; y < (vSegs-1); y++) {\u000a            for (var x = 0; x < (uSegs-1); x++) {\u000a                var a = y*uSegs + x;\u000a                var b = a+1;\u000a                var c = a+uSegs;\u000a                var d = c+1;\u000a                indices[ndx] = a;\u000a                indices[ndx+1] = b;\u000a                indices[ndx+2] = c;\u000a                indices[ndx+3] = b;\u000a                indices[ndx+4] = d;\u000a                indices[ndx+5] = c;\u000a                ndx += 6;\u000a            }\u000a            if (closedU) {\u000a                var a = y*uSegs + uSegs-1;\u000a                var b = y*uSegs;\u000a                var c = a+uSegs;\u000a                var d = b+uSegs;\u000a                indices[ndx] = a;\u000a                indices[ndx+1] = b;\u000a                indices[ndx+2] = c;\u000a                indices[ndx+3] = b;\u000a                indices[ndx+4] = d;\u000a                indices[ndx+5] = c;\u000a                ndx += 6;\u000a            }\u000a        }\u000a        if (closedV) {\u000a            for (var x = 0; x < (uSegs-1); x++) {\u000a                var a = (vSegs-1)*uSegs + x;\u000a                var b = a+1;\u000a                var c = x;\u000a                var d = c+1;\u000a                indices[ndx] = a;\u000a                indices[ndx+1] = b;\u000a                indices[ndx+2] = c;\u000a                indices[ndx+3] = b;\u000a                indices[ndx+4] = d;\u000a                indices[ndx+5] = c;\u000a                ndx += 6;\u000a            }\u000a            if (closedU) {\u000a                var a = (vSegs-1)*uSegs + uSegs-1;\u000a                var b = (vSegs-1)*uSegs;\u000a                var c = uSegs-1;\u000a                var d = 0;\u000a                indices[ndx] = a;\u000a                indices[ndx+1] = b;\u000a                indices[ndx+2] = c;\u000a                indices[ndx+3] = b;\u000a                indices[ndx+4] = d;\u000a                indices[ndx+5] = c;\u000a                ndx += 6;\u000a            }\u000a        }\u000a        \u000a        \u000a        \u000a        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glc.indexBuffer);\u000a        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\u000a        glc.numElements = indices.length;\u000a    }\u000a    \u000a    glc.refreshUVMesh = refreshUVMesh;\u000a    \u000a    \u000a       \u000a    \u000a    function draw(glc) {\u000a        var gl = glc.gl;\u000a        \u000a        gl.clearColor(0.0, 0.0, 0.0, 1.0);\u000a        gl.enable(gl.DEPTH_TEST);\u000a        gl.depthFunc(gl.LEQUAL);\u000a        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\u000a        \u000a        gl.useProgram(glc.shaderProgram);\u000a        \u000a        // Apply camera\u000a        glc.apply(gl);\u000a\u000a        \u000a        //\u000a        // OBJECT\u000a        //\u000a        \u000a        gl.bindBuffer(gl.ARRAY_BUFFER, glc.verticesBuffer);\u000a        var offset = 0;\u000a        for (var i = 0; i < glc.attribLocations.length; i++) {\u000a            gl.vertexAttribPointer(glc.attribLocations[i], glc.attribSizes[i], gl.FLOAT, false, glc.attribStride*4, offset*4);\u000a            offset += glc.attribSizes[i];\u000a        }\u000a        \u000a        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glc.indexBuffer);\u000a        gl.drawElements(gl.TRIANGLES, glc.numElements, gl.UNSIGNED_SHORT, 0);\u000a    }\u000a    \u000a    glc.draw = draw;\u000a    \u000a    return glc;\u000a}\u000a\u000a\u000afunction LiteralUVMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData) {\u000a    var glc = UVMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius);\u000a    glc.refreshUVMesh(uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData);\u000a    glc.redraw();\u000a    \u000a    return glc;\u000a}\u000a\u000a\u000afunction ResourceUVMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, rsc) {\u000a    var glc = UVMeshCanvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius);\u000a    function update() {\u000a        rsc.fetchJSON(function(data) {\u000a		    glc.refreshUVMesh(data.uSegs, data.vSegs, data.closedU, data.closedV, data.vertexPositions, data.vertexAttribsNamesSizesData);\u000a            glc.redraw();\u000a        });\u000a    };\u000a        \u000a    rsc.addListener(update);\u000a    update();\u000a    \u000a    return glc;\u000a}\u000a
p46
sS'editable'
p47
I01
sbsS'var_name'
p48
Vinitwebgl_js
p49
sbag0
(g30
g2
Ntp50
Rp51
(dp52
g34
g26
sg35
V<p>Finally, we test:</p>
p53
sbag0
(clarch.worksheet.worksheet
WorksheetBlockCode
p54
g2
Ntp55
Rp56
(dp57
g34
g26
sg41
g0
(clarch.source_code
PythonCode
p58
g2
Ntp59
Rp60
(dp61
g41
Vfrom britefury.pres.html import Html\u000a\u000a\u000adef gl_canvas_with_literal_mesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, modesAndIndices\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices).use_js(source=initwebgl_js).use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_literal_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralUVMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data).use_js(source=initwebgl_js).use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_rsc_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, resource):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, resource\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'ResourceUVMeshCanvas', vs_source, fs_source, 45.0, [0.0, 0.0, 0.0], 12.0, resource).use_js(source=initwebgl_js).use_js(url='/gl-matrix-min.js')\u000a
p62
sg47
I01
sbsbasbsg16
Vwebgl_canvas
p63
sS'id'
p64
I0
sbasbag0
(g12
g2
Ntp65
Rp66
(dp67
g16
VExamples
p68
sg10
(lp69
g0
(g19
g2
Ntp70
Rp71
(dp72
g23
g0
(g24
g2
Ntp73
Rp74
(dp75
g28
(lp76
g0
(g30
g2
Ntp77
Rp78
(dp79
g34
g74
sg35
V<h1>Torus examples</h1><p>First, import the uv mesh stuff:</p>
p80
sbag0
(g54
g2
Ntp81
Rp82
(dp83
g34
g74
sg41
g0
(g58
g2
Ntp84
Rp85
(dp86
g41
Vimport math\u000a\u000afrom britefury.live.live_function import LiveFunction\u000afrom britefury.live.live_value import LiveValue\u000afrom britefury.pres.resource import JsonLiveFnResource\u000afrom britefury.pres.controls import slider\u000a\u000afrom Lib.webgl_canvas import *
p87
sg47
I01
sbsbag0
(g30
g2
Ntp88
Rp89
(dp90
g34
g74
sg35
V<p>Now, we need some basic shaders. Plain white for this example. Fragment shader first:</p>
p91
sbag0
(g37
g2
Ntp92
Rp93
(dp94
g34
g74
sg41
g0
(clarch.source_code
GLSLCode
p95
g2
Ntp96
Rp97
(dp98
g41
Vprecision mediump float;\u000a\u000avarying vec3 colour;\u000a\u000avoid main(void) {\u000a    gl_FragColor = vec4(colour, 1.0)*0.5+0.5;\u000a}
p99
sg47
I01
sbsg48
Vfshader_glsl
p100
sbag0
(g30
g2
Ntp101
Rp102
(dp103
g34
g74
sg35
V<p>The vertex shader:</p>
p104
sbag0
(g37
g2
Ntp105
Rp106
(dp107
g34
g74
sg41
g0
(g95
g2
Ntp108
Rp109
(dp110
g41
Vattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000a\u000avarying vec3 colour;\u000a  \u000a\u000avoid main(void) {\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a    colour = vec3(dot(vertexNrm, vec3(0,1,0)));\u000a}
p111
sg47
I01
sbsg48
Vvshader_glsl
p112
sbag0
(g30
g2
Ntp113
Rp114
(dp115
g34
g74
sg35
V<h1>Building a torus</h1><p>We need to build a torus in two ways; as a mesh, and as a UV mesh where the structure of the model is implicit. Mesh first (generate both vertices and indices):</p>
p116
sbag0
(g54
g2
Ntp117
Rp118
(dp119
g34
g74
sg41
g0
(g58
g2
Ntp120
Rp121
(dp122
g41
Vdef mesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices
p123
sg47
I01
sbsbag0
(g30
g2
Ntp124
Rp125
(dp126
g34
g74
sg35
V<p>Now for the UV mesh:</p>
p127
sbag0
(g54
g2
Ntp128
Rp129
(dp130
g34
g74
sg41
g0
(g58
g2
Ntp131
Rp132
(dp133
g41
Vdef uvmesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices
p134
sg47
I01
sbsbag0
(g30
g2
Ntp135
Rp136
(dp137
g34
g74
sg35
V<h1>Example: mesh torus</h1>
p138
sbag0
(g54
g2
Ntp139
Rp140
(dp141
g34
g74
sg41
g0
(g58
g2
Ntp142
Rp143
(dp144
g41
Vmesh_verts, mesh_indices = mesh_torus(4.0, 32, 1.0, 16)\u000agl_canvas_with_literal_mesh(800, 600, vshader_glsl, fshader_glsl, 45.0, [0.0, 0.0, 0.0], 12.0, [['vertexPos', 3], ['vertexNrm', 3]], mesh_verts, [['triangles', mesh_indices]])
p145
sg47
I01
sbsbag0
(g30
g2
Ntp146
Rp147
(dp148
g34
g74
sg35
V<p>Example: UV mesh torus</p>
p149
sbag0
(g54
g2
Ntp150
Rp151
(dp152
g34
g74
sg41
g0
(g58
g2
Ntp153
Rp154
(dp155
g41
Vuvmesh_vertpos = uvmesh_torus(4.0, 32, 1.0, 16)\u000agl_canvas_with_literal_uvmesh(800, 600, vshader_glsl, fshader_glsl, 45.0, [0.0, 0.0, 0.0], 12.0, 16, 32, True, True, uvmesh_vertpos, [])
p156
sg47
I01
sbsbag0
(g30
g2
Ntp157
Rp158
(dp159
g34
g74
sg35
V<h1>Example: UV mesh torus as resource</h1>
p160
sbag0
(g54
g2
Ntp161
Rp162
(dp163
g34
g74
sg41
g0
(g58
g2
Ntp164
Rp165
(dp166
g41
Vmaj_rad = LiveValue(40)\u000amin_rad = LiveValue(10) \u000amaj_segs = LiveValue(32)\u000amin_segs = LiveValue(16) \u000a\u000a\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef torus_rsc():\u000a    vertices = uvmesh_torus(float(maj_rad.value)*0.1, maj_segs.value, float(min_rad.value)*0.1, min_segs.value)\u000a    return {\u000a            'uSegs': min_segs.value,\u000a            'vSegs': maj_segs.value,\u000a            'closedU': True,\u000a            'closedV': True,\u000a            'vertexPositions': vertices,\u000a            'vertexAttribsNamesSizesData': []\u000a            }\u000a\u000a\u000amaj_rad_slider = slider.live_slider(maj_rad, True)\u000amin_rad_slider = slider.live_slider(min_rad, True)\u000a\u000amaj_segs_slider = slider.live_slider(maj_segs, True)\u000amin_segs_slider = slider.live_slider(min_segs, True)\u000a\u000acanvas = gl_canvas_with_rsc_uvmesh(800, 600, vshader_glsl, fshader_glsl, 45.0, [0.0, 0.0, 0.0], 12.0, torus_rsc)\u000aHtml(canvas, '<br>Major radius: ', maj_rad_slider, 'Major segments: ', maj_segs_slider, 'Minor radius: ', min_rad_slider, 'Minor segments: ', min_segs_slider)
p167
sg47
I01
sbsbasbsg16
VTorusExamples
p168
sg64
I1
sbasbasb.