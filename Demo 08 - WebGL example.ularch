ccopy_reg
_reconstructor
p0
(clarch.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
g0
(clarch.project.project_page
ProjectPage
p19
g2
Ntp20
Rp21
(dp22
S'data'
p23
g0
(clarch.worksheet.worksheet
Worksheet
p24
g2
Ntp25
Rp26
(dp27
S'blocks'
p28
(lp29
g0
(clarch.worksheet.worksheet
WorksheetBlockText
p30
g2
Ntp31
Rp32
(dp33
S'worksheet'
p34
g26
sS'text'
p35
V<h1>WebGL Canvas</h1><p>First, we implement the Javascript code that renders objects using WebGL:</p>
p36
sbag0
(g30
g2
Ntp37
Rp38
(dp39
g34
g26
sg35
V<p>Define WebGL canvas Python functions:</p>
p40
sbag0
(clarch.worksheet.worksheet
WorksheetBlockCode
p41
g2
Ntp42
Rp43
(dp44
g34
g26
sS'code'
p45
g0
(clarch.source_code
PythonCode
p46
g2
Ntp47
Rp48
(dp49
g45
Vfrom britefury.pres.html import Html\u000a\u000a\u000adef gl_canvas_with_literal_mesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, modesAndIndices\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_literal_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralUVMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_rsc_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, resource):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, resource\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'ResourceUVMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, resource).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a
p50
sS'editable'
p51
I01
sbsbag0
(g30
g2
Ntp52
Rp53
(dp54
g34
g26
sg35
V<h1>Plain white shader</h1><p>Fragment:</p>
p55
sbag0
(clarch.worksheet.worksheet
WorksheetBlockSource
p56
g2
Ntp57
Rp58
(dp59
g34
g26
sg45
g0
(clarch.source_code
GLSLCode
p60
g2
Ntp61
Rp62
(dp63
g45
Vprecision mediump float;\u000a\u000avarying vec3 colour;\u000a\u000avoid main(void) {\u000a    gl_FragColor = vec4(colour, 1.0)*0.5+0.5;\u000a}
p64
sg51
I01
sbsS'var_name'
p65
Vplainwhite_fshader
p66
sbag0
(g30
g2
Ntp67
Rp68
(dp69
g34
g26
sg35
V<p>Vertex:</p>
p70
sbag0
(g56
g2
Ntp71
Rp72
(dp73
g34
g26
sg45
g0
(g60
g2
Ntp74
Rp75
(dp76
g45
Vattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000a\u000avarying vec3 colour;\u000a  \u000a\u000avoid main(void) {\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a    colour = vec3(dot(vertexNrm, vec3(0,1,0)));\u000a}
p77
sg51
I01
sbsg65
Vplainwhite_vshader
p78
sbasbsg16
Vwebgl_canvas
p79
sS'id'
p80
I0
sbasbag0
(g12
g2
Ntp81
Rp82
(dp83
g16
VExamples
p84
sg10
(lp85
g0
(g19
g2
Ntp86
Rp87
(dp88
g23
g0
(g24
g2
Ntp89
Rp90
(dp91
g28
(lp92
g0
(g30
g2
Ntp93
Rp94
(dp95
g34
g90
sg35
V<h1>Torus examples</h1><p>First, import the uv mesh stuff:</p>
p96
sbag0
(g41
g2
Ntp97
Rp98
(dp99
g34
g90
sg45
g0
(g46
g2
Ntp100
Rp101
(dp102
g45
Vimport math\u000a\u000afrom britefury.live import LiveFunction, LiveValue\u000afrom britefury.pres.resource import JsonLiveFnResource\u000afrom britefury.pres.controls import slider\u000afrom britefury.pres.html import Html\u000a\u000afrom larch import webglscene
p103
sg51
I01
sbsbag0
(g30
g2
Ntp104
Rp105
(dp106
g34
g90
sg35
V<h1>Setting up the scene</h1><p>First, we set up a camera and the shader:</p>
p107
sbag0
(g41
g2
Ntp108
Rp109
(dp110
g34
g90
sg45
g0
(g46
g2
Ntp111
Rp112
(dp113
g45
Vcam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 12.0, 0.0, math.radians(30.0))\u000amaterial = webglscene.Material.plain_white\u000a
p114
sg51
I01
sbsbag0
(g30
g2
Ntp115
Rp116
(dp117
g34
g90
sg35
V<h1>Building a torus</h1><p>We need to build a torus in two ways; as a mesh, and as a UV mesh where the structure of the model is implicit. Mesh first (generate both vertices and indices):</p>
p118
sbag0
(g41
g2
Ntp119
Rp120
(dp121
g34
g90
sg45
g0
(g46
g2
Ntp122
Rp123
(dp124
g45
Vdef mesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices
p125
sg51
I01
sbsbag0
(g30
g2
Ntp126
Rp127
(dp128
g34
g90
sg35
V<p>Now for the UV mesh:</p>
p129
sbag0
(g41
g2
Ntp130
Rp131
(dp132
g34
g90
sg45
g0
(g46
g2
Ntp133
Rp134
(dp135
g45
Vdef uvmesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices
p136
sg51
I01
sbsbag0
(g30
g2
Ntp137
Rp138
(dp139
g34
g90
sg35
V<h1>Example: mesh torus</h1>
p140
sbag0
(g41
g2
Ntp141
Rp142
(dp143
g34
g90
sg45
g0
(g46
g2
Ntp144
Rp145
(dp146
g45
Vmesh_verts, mesh_indices = mesh_torus(4.0, 32, 1.0, 16)\u000atorus_mesh = webglscene.MeshEntity(material, [['vertexPos', 3], ['vertexNrm', 3]], mesh_verts, [['triangles', mesh_indices]])\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [torus_mesh]))
p147
sg51
I01
sbsbag0
(g30
g2
Ntp148
Rp149
(dp150
g34
g90
sg35
V<p>Example: UV mesh torus</p>
p151
sbag0
(g41
g2
Ntp152
Rp153
(dp154
g34
g90
sg45
g0
(g46
g2
Ntp155
Rp156
(dp157
g45
Vuvmesh_vertpos = uvmesh_torus(4.0, 32, 1.0, 16)\u000a\u000auvsource = webglscene.UVMeshDataLiteral(16, 32, True, True, uvmesh_vertpos, [])\u000auvtorus = webglscene.UVMeshEntity(material, uvsource)\u000a\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvtorus]))
p158
sg51
I01
sbsbag0
(g30
g2
Ntp159
Rp160
(dp161
g34
g90
sg35
V<h1>Example: UV mesh torus as resource</h1>
p162
sbag0
(g41
g2
Ntp163
Rp164
(dp165
g34
g90
sg45
g0
(g46
g2
Ntp166
Rp167
(dp168
g45
Vmaj_rad = LiveValue(40)\u000amin_rad = LiveValue(10) \u000amaj_segs = LiveValue(32)\u000amin_segs = LiveValue(16) \u000a\u000a\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef torus_rsc():\u000a    vertices = uvmesh_torus(float(maj_rad.value)*0.1, maj_segs.value, float(min_rad.value)*0.1, min_segs.value)\u000a    return {\u000a            'uSegs': min_segs.value,\u000a            'vSegs': maj_segs.value,\u000a            'closedU': True,\u000a            'closedV': True,\u000a            'vertexPositions': vertices,\u000a            'vertexAttribsNamesSizesData': []\u000a            }\u000a\u000a\u000amaj_rad_slider = slider.live_slider(maj_rad, True)\u000amin_rad_slider = slider.live_slider(min_rad, True)\u000a\u000amaj_segs_slider = slider.live_slider(maj_segs, True)\u000amin_segs_slider = slider.live_slider(min_segs, True)\u000a\u000auvrsc = webglscene.UVMeshDataResource(torus_rsc)\u000auvrsctorus = webglscene.UVMeshEntity(material, uvrsc)\u000a\u000acanvas = webglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvrsctorus]))\u000aHtml(canvas, '<br>Major radius: ', maj_rad_slider, 'Major segments: ', maj_segs_slider, 'Minor radius: ', min_rad_slider, 'Minor segments: ', min_segs_slider)
p169
sg51
I01
sbsbasbsg16
VTorusExamples
p170
sg80
I1
sbasbag0
(g19
g2
Ntp171
Rp172
(dp173
g23
g0
(g24
g2
Ntp174
Rp175
(dp176
g28
(lp177
g0
(g30
g2
Ntp178
Rp179
(dp180
g34
g175
sg35
V<h1>3D Plotting</h1><p>Imports first:</p>
p181
sbag0
(g41
g2
Ntp182
Rp183
(dp184
g34
g175
sg45
g0
(g46
g2
Ntp185
Rp186
(dp187
g45
Vimport math\u000a\u000afrom britefury.live import LiveFunction, LiveValue\u000afrom britefury.pres.resource import JsonLiveFnResource\u000afrom britefury.pres.controls import slider\u000afrom britefury.pres.html import Html\u000a\u000afrom larch import webglscene
p188
sg51
I01
sbsbag0
(g30
g2
Ntp189
Rp190
(dp191
g34
g175
sg35
V<p>Now define 3D plotting function:</p>
p192
sbag0
(g41
g2
Ntp193
Rp194
(dp195
g34
g175
sg45
g0
(g46
g2
Ntp196
Rp197
(dp198
g45
Vdef plot3d_entity(data, width, depth, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a    \u000a    return uvmesh\u000a
p199
sg51
I01
sbsbag0
(g41
g2
Ntp200
Rp201
(dp202
g34
g175
sg45
g0
(g46
g2
Ntp203
Rp204
(dp205
g45
Vdef plot3d(data, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    uvmesh = plot3d_entity(data, width, depth, material=material)\u000a    \u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    focal_y = (min_y + max_y) * 0.5\u000a    \u000a    dim = max(width, depth, max_y - min_y)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, focal_y, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a\u000a
p206
sg51
I01
sbsbag0
(g30
g2
Ntp207
Rp208
(dp209
g34
g175
sg35
V<p>Live plotting:</p>
p210
sbag0
(g41
g2
Ntp211
Rp212
(dp213
g34
g175
sg45
g0
(g46
g2
Ntp214
Rp215
(dp216
g45
Vdef plot3d_live(data_live, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    @JsonLiveFnResource\u000a    @LiveFunction\u000a    def plot_rsc():\u000a        data = data_live.value\u000a        \u000a        v_segs = len(data)\u000a        u_segs = len(data[0])\u000a        \u000a        vertex_positions = []\u000a        vertex_attribs_names_sizes_data = []\u000a        if generate_tex_coords:\u000a            vertex_tex = []\u000a            vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a        \u000a        \u000a        delta_z = depth / v_segs\u000a        delta_x = width / u_segs\u000a        delta_s = 1.0 / u_segs\u000a        delta_t = 1.0 / v_segs\u000a    \u000a        z = depth * -0.5\u000a        t = 0.0\u000a        for row in data:\u000a            x = width * -0.5\u000a            s = 0.0\u000a            for col in row:\u000a                vertex_positions.extend([x, col, z])\u000a                if generate_tex_coords:\u000a                    vertex_tex.extend([s, t])\u000a                x += delta_x\u000a                s += delta_s\u000a            z += delta_z\u000a            t += delta_t\u000a\u000a        return {\u000a                'uSegs': u_segs,\u000a                'vSegs': v_segs,\u000a                'closedU': False,\u000a                'closedV': False,\u000a                'vertexPositions': vertex_positions,\u000a                'vertexAttribsNamesSizesData': vertex_attribs_names_sizes_data\u000a                }\u000a    \u000a    dim = max(width, depth)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataResource(plot_rsc)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a
p217
sg51
I01
sbsbag0
(g30
g2
Ntp218
Rp219
(dp220
g34
g175
sg35
V<p>Test (literal first):</p>
p221
sbag0
(g41
g2
Ntp222
Rp223
(dp224
g34
g175
sg45
g0
(g46
g2
Ntp225
Rp226
(dp227
g45
Vplot3d([[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)], 100.0, 100.0)
p228
sg51
I01
sbsbag0
(g30
g2
Ntp229
Rp230
(dp231
g34
g175
sg35
V<p>Now live data:</p>
p232
sbag0
(g41
g2
Ntp233
Rp234
(dp235
g34
g175
sg45
g0
(g46
g2
Ntp236
Rp237
(dp238
g45
Vu_scale = LiveValue(10)\u000av_scale = LiveValue(10) \u000a\u000a\u000a@LiveFunction\u000adef data():\u000a    us = u_scale.value*0.01\u000a    vs = v_scale.value*0.01\u000a    return [[float(((i-8)**2)*us+((j-8)**2))*vs   for i in xrange(16)] for j in xrange(16)]\u000a    #return [[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)]\u000a\u000au_slider = slider.live_slider(u_scale, True)\u000av_slider = slider.live_slider(v_scale, True)\u000a\u000acanvas = plot3d_live(data, 100.0, 100.0)\u000aHtml(canvas, '<br>U scale: ', u_slider, 'V scale: ', v_slider)
p239
sg51
I01
sbsbasbsg16
Vplot3d
p240
sg80
I2
sbag0
(g19
g2
Ntp241
Rp242
(dp243
g23
g0
(g24
g2
Ntp244
Rp245
(dp246
g28
(lp247
g0
(g41
g2
Ntp248
Rp249
(dp250
g34
g245
sg45
g0
(g46
g2
Ntp251
Rp252
(dp253
g45
Vimport math\u000aimport numpy as np\u000aimport random\u000a#from matplotlib import *\u000a\u000aimport plot3d\u000a\u000a\u000a\u000a\u000aclass PhilipsSpectrum (object):\u000a    def __init__(self, wave_height_factor, wind_speed, wind_vector, gravitational_constant, smoothness):\u000a        wind_inv_len = 1.0/math.sqrt(wind_vector[0]*wind_vector[0] + wind_vector[1]*wind_vector[1])\u000a        wind_vector[0] *= wind_inv_len\u000a        wind_vector[1] *= wind_inv_len\u000a        \u000a        self.wave_height_factor = wave_height_factor\u000a        self.wind_speed = wind_speed\u000a        self.wind_vector = wind_vector\u000a        self.largest_wave = wind_speed * wind_speed / gravitational_constant\u000a        self.gravitational_constant = gravitational_constant\u000a        self.smoothness = smoothness\u000a\u000a        \u000a\u000a    def philips_spectrum(self, kx, ky):\u000a        k_length = math.sqrt(kx*kx + ky*ky)\u000a        j = k_length / (2.0 * math.pi)\u000a        j2 = j * j\u000a        j4 = j2 * j2\u000a    \u000a        a = self.wave_height_factor\u000a        jl = j * self.largest_wave\u000a        e_ = -1.0 / (jl * jl)\u000a        b = math.exp(e_) / j4\u000a        knx = kx / k_length\u000a        kny = ky / k_length\u000a        k_dot_w = knx * self.wind_vector[0]  +  kny * self.wind_vector[1]\u000a        c = k_dot_w * k_dot_w\u000a        l = self.largest_wave * self.smoothness\u000a        d = math.exp(-j2 * l*l)\u000a\u000a        return a * b * c * d\u000a\u000a    \u000a    \u000a    def philips_matrix(self, size, resolution):\u000a        n_verts = resolution + 1\u000a        \u000a        k = np.linspace(0.0, 2.0 * math.pi * resolution / size, n_verts)\u000a        \u000a        inv_sqrt_2 = 1.0 / math.sqrt(2.0)\u000a        \u000a        philips = np.zeros((n_verts, n_verts))\u000a        \u000a        for y in xrange(n_verts):\u000a            for x in xrange(n_verts):\u000a                if x != 0  or  y != 0:\u000a                    p = self.philips_spectrum(k[x], k[y])\u000a                else:\u000a                    p = 0.0\u000a                q = inv_sqrt_2 * math.sqrt(p)\u000a                \u000a                philips[y,x] = q\u000a        \u000a        return philips\u000a    \u000a    \u000a    \u000a    \u000aclass Ocean (object):\u000a    def __init__(self, rnd_state, size, resolution, time_step):\u000a        \u000a        self.gravitational_constant = 1.0\u000a        self.size = size\u000a        self.resolution = resolution\u000a        self.n_verts = resolution + 1\u000a        self.time_step = time_step\u000a        \u000a        self.freq_rnd = rnd_state.randn(self.n_verts, self.n_verts) + rnd_state.randn(self.n_verts, self.n_verts) * 1j\u000a        self.freq = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.heights = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.single_step = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        self.step_table = []\u000a        \u000a        self.vertex_positions = []\u000a        \u000a        self.__update_step_table()\u000a        \u000a        \u000a    \u000a    def __update_step_table(self):\u000a        for y in xrange(self.n_verts):\u000a            for x in xrange(self.n_verts):\u000a                ux = x / self.size\u000a                uy = y / self.size\u000a                u = math.sqrt(ux*ux +uy*uy)\u000a                omega = math.sqrt(u * self.gravitational_constant) * self.time_step\u000a                c = math.cos(omega)\u000a                s = math.sin(omega)\u000a                self.single_step[y,x] = c + s *  1j\u000a                self.step_table = [self.single_step]\u000a        \u000a    \u000a    def apply_philips(self, spectrum):\u000a        philips = spectrum.philips_matrix(self.size, self.resolution)\u000a        \u000a        g_changed = self.gravitational_constant != spectrum.gravitational_constant\u000a        if g_changed:\u000a            self.gravitational_constant = spectrum.gravitational_constant\u000a            self.__update_step_table()\u000a        \u000a        \u000a        self.freq = self.freq_rnd * philips\u000a        \u000a                \u000a                \u000a                \u000a    def step(self, delta_t):\u000a        steps = int(delta_t / self.time_step)\u000a        if steps != 0:\u000a            ndx = steps - 1\u000a            try:\u000a                u = self.step_table[ndx]\u000a            except IndexError:\u000a                u = self.step_table[-1]\u000a                for i in xrange(len(self.step_table),ndx):\u000a                    u = u * self.single_step\u000a                    self.step_table.append(u)\u000a            \u000a            self.freq = self.freq * u\u000a        \u000a        \u000a    def update_heights(self):\u000a        spatial = np.fft.fft2(self.freq)\u000a        self.heights = np.array(spatial, dtype=float)\u000a        \u000a        self.vertex_positions = []\u000a        dx = self.size / self.resolution\u000a        z = 0.0\u000a        for j in xrange(self.n_verts):\u000a            x = 0.0\u000a            for i in xrange(self.n_verts):\u000a                self.vertex_positions.extend([x,self.heights[j,i],z])\u000a                x += dx\u000a            z += dx\u000a                \u000a                \u000a    \u000a    \u000a\u000a#o = Ocean(random.Random(123), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000a#o = Ocean(random.Random(223783), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000aphilips_spectrum = PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000ao = Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000ao.apply_philips(philips_spectrum)\u000a\u000ao.step(0.5)\u000ao.update_heights()\u000a#imshow(o.heights)\u000a\u000aplot3d.plot3d(o.heights, o.size, o.size)
p254
sg51
I01
sbsbasbsg16
Vocean
p255
sg80
I3
sbag0
(g19
g2
Ntp256
Rp257
(dp258
g23
g0
(g24
g2
Ntp259
Rp260
(dp261
g28
(lp262
g0
(g41
g2
Ntp263
Rp264
(dp265
g34
g260
sg45
g0
(g46
g2
Ntp266
Rp267
(dp268
g45
Vimport numpy as np\u000afrom scipy import interpolate\u000afrom larch import webglscene\u000afrom britefury.pres.resource import ImageFromFile\u000aimport plot3d\u000a\u000a\u000a\u000adef make_harmonic(rnd, resolution, magnitude):\u000a    return rnd.randn(resolution+1, resolution+1) * magnitude\u000a\u000a\u000adef upscale_harmonic(h, resolution):\u000a    x = np.linspace(0.0, 1.0, len(h))\u000a    p = interpolate.interp2d(x, x, h, kind='cubic')\u000a    x_new = np.linspace(0.0, 1.0, resolution+1)\u000a    return p(x_new, x_new)\u000a    \u000a\u000a    \u000adef fractal_heightfield(rand_state, resolution, size, n_harmonics, top_h_res, magnitude, mag_scale):\u000a    # Generate harmonics\u000a    harmonics = []\u000a    h_res = top_h_res\u000a    h_mag = magnitude * mag_scale**(n_harmonics-1)\u000a    for i in xrange(n_harmonics):\u000a        h = make_harmonic(rand_state, h_res, h_mag)\u000a        h = upscale_harmonic(h, resolution)\u000a        harmonics.append(h)\u000a        h_res /= 2\u000a        h_mag = h_mag / mag_scale\u000a    \u000a    return sum(harmonics)\u000a    \u000a\u000a\u000ah = fractal_heightfield(np.random.RandomState(123), 128, 100.0, 4, 32, 5.0, 0.3)\u000amaterial=webglscene.Material.single_texture_2d(ImageFromFile('testimages/Sand.jpg'))\u000aplot3d.plot3d(h, len(h), len(h[0]), material=material, generate_tex_coords=True)
p269
sg51
I01
sbsbasbsg16
Vfractal_landscape
p270
sg80
I4
sbag0
(g19
g2
Ntp271
Rp272
(dp273
g23
g0
(g24
g2
Ntp274
Rp275
(dp276
g28
(lp277
g0
(g30
g2
Ntp278
Rp279
(dp280
g34
g275
sg35
V<h1>The final scene</h1><h2>Shaders</h2>
p281
sbag0
(g30
g2
Ntp282
Rp283
(dp284
g34
g275
sg35
V<h3>Surface shaders</h3><p>Ocean: plain</p>
p285
sbag0
(g56
g2
Ntp286
Rp287
(dp288
g34
g275
sg45
g0
(g60
g2
Ntp289
Rp290
(dp291
g45
Vvoid surface(void) {\u000a	colour = vec3(dot(vertexNrm, vec3(0,1,0))) * vec3(0.0, 0.5, 1.0);\u000a}
p292
sg51
I01
sbsg65
Vocean_plain_vert
p293
sbag0
(g56
g2
Ntp294
Rp295
(dp296
g34
g275
sg45
g0
(g60
g2
Ntp297
Rp298
(dp299
g45
Vvec4 surface(void) {\u000a	return vec4(colour, 1.0)*0.5+0.5;\u000a}
p300
sg51
I01
sbsg65
Vocean_plain_frag
p301
sbag0
(g30
g2
Ntp302
Rp303
(dp304
g34
g275
sg35
V<p>Ocean: fresnel</p>
p305
sbag0
(g56
g2
Ntp306
Rp307
(dp308
g34
g275
sg45
g0
(g60
g2
Ntp309
Rp310
(dp311
g45
Vconst float f0 = 0.05;\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avoid surface(void)\u000a{\u000a	vec3 worldSpaceEye = normalize( camPos.xyz - vertexPos.xyz );\u000a	\u000a	vec3 normal = dot( vertexNrm, worldSpaceEye )  >  0.0  ?  vertexNrm  :  -vertexNrm;\u000a	\u000a	float cosTheta = dot( worldSpaceEye, normal );\u000a	float omCosTheta = 1.0 - cosTheta;\u000a	float omCosTheta2 = omCosTheta * omCosTheta;\u000a	float omCosTheta4 = omCosTheta2 * omCosTheta2;\u000a	float omCosTheta5 = omCosTheta4 * omCosTheta;\u000a	frag_surf_water_f = f0  +  omCosTheta5 * ( 1.0 - f0 );\u000a	\u000a	float nDotE = dot( normal, worldSpaceEye );\u000a	vec3 projN = normal * nDotE;\u000a	frag_surf_water_refl = projN - ( worldSpaceEye - projN );\u000a}\u000a
p312
sg51
I01
sbsg65
Vocean_fresnel_vert
p313
sbag0
(g56
g2
Ntp314
Rp315
(dp316
g34
g275
sg45
g0
(g60
g2
Ntp317
Rp318
(dp319
g45
Vconst vec3 refrCol = vec3( vec3( 0.090, 0.341, 0.482 )*0.75 );\u000a\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	vec3 col = mix(refrCol, reflCol, frag_surf_water_f);\u000a\u000a	return vec4( col, 1.0 );\u000a}\u000a
p320
sg51
I01
sbsg65
Vocean_fresnel_frag
p321
sbag0
(g56
g2
Ntp322
Rp323
(dp324
g34
g275
sg45
g0
(g60
g2
Ntp325
Rp326
(dp327
g45
Vvarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	return vec4( reflCol * frag_surf_water_f, 1.0 - frag_surf_water_f );\u000a}\u000a
p328
sg51
I01
sbsg65
Vocean_transparent_fresnel_frag
p329
sbag0
(g30
g2
Ntp330
Rp331
(dp332
g34
g275
sg35
V<p>Terrain</p>
p333
sbag0
(g56
g2
Ntp334
Rp335
(dp336
g34
g275
sg45
g0
(g60
g2
Ntp337
Rp338
(dp339
g45
Vattribute vec2 vertexTex;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avoid surface(void) {\u000a	lighting = vec3(dot(vertexNrm, vec3(0,1,0)))*0.5+0.5;\u000a	texCoord = vertexTex;\u000a}
p340
sg51
I01
sbsg65
Vterrain_vert
p341
sbag0
(g56
g2
Ntp342
Rp343
(dp344
g34
g275
sg45
g0
(g60
g2
Ntp345
Rp346
(dp347
g45
Vuniform sampler2D sampler;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avec4 surface(void) {\u000a	return texture2D(sampler, texCoord) * vec4(lighting, 1.0);\u000a}\u000a
p348
sg51
I01
sbsg65
Vterrain_frag
p349
sbag0
(g30
g2
Ntp350
Rp351
(dp352
g34
g275
sg35
V<h3>Volume shaders</h3><p>Identity</p>
p353
sbag0
(g56
g2
Ntp354
Rp355
(dp356
g34
g275
sg45
g0
(g60
g2
Ntp357
Rp358
(dp359
g45
Vvoid volume(void)\u000a{\u000a}\u000a
p360
sg51
I01
sbsg65
Vvol_identity_vert
p361
sbag0
(g56
g2
Ntp362
Rp363
(dp364
g34
g275
sg45
g0
(g60
g2
Ntp365
Rp366
(dp367
g45
Vvec4 volume(vec4 surface)\u000a{\u000a	return surface;\u000a}\u000a
p368
sg51
I01
sbsg65
Vvol_identity_frag
p369
sbag0
(g30
g2
Ntp370
Rp371
(dp372
g34
g275
sg35
V<p>Oceanic fog</p>
p373
sbag0
(g56
g2
Ntp374
Rp375
(dp376
g34
g275
sg45
g0
(g60
g2
Ntp377
Rp378
(dp379
g45
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 1.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y > 0.0  &&  vertexPos.y > 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( camPos.y <= 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else if ( camPos.y > 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera above water, vertex below water\u000a			y1 = -vertexPos.y;\u000a			float fracBelowWater = y1 / ( camPos.y + y1 );\u000a			distance *= fracBelowWater;\u000a			y0 = 0.0;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p380
sg51
I01
sbsg65
Vvol_oceanfog_vert
p381
sbag0
(g56
g2
Ntp382
Rp383
(dp384
g34
g275
sg45
g0
(g60
g2
Ntp385
Rp386
(dp387
g45
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 2.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1,1,1)*(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y >= 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p388
sg51
I01
sbsg65
Vvol_oceanfog_forocean_vert
p389
sbag0
(g56
g2
Ntp390
Rp391
(dp392
g34
g275
sg45
g0
(g60
g2
Ntp393
Rp394
(dp395
g45
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, 1.0 );\u000a}
p396
sg51
I01
sbsg65
Vvol_oceanfog_frag
p397
sbag0
(g56
g2
Ntp398
Rp399
(dp400
g34
g275
sg45
g0
(g60
g2
Ntp401
Rp402
(dp403
g45
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	float transparency = frag_vol_oceanFog_transparency.a;\u000a	float alpha = surface.a * transparency;\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, alpha );\u000a}\u000a
p404
sg51
I01
sbsg65
Vvol_oceanfog_transparent_frag
p405
sbag0
(g30
g2
Ntp406
Rp407
(dp408
g34
g275
sg35
V<h3>Overall shader</h3>
p409
sbag0
(g56
g2
Ntp410
Rp411
(dp412
g34
g275
sg45
g0
(g60
g2
Ntp413
Rp414
(dp415
g45
Vprecision highp float;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000auniform vec4 camPos;\u000a\u000aattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000avarying vec3 colour;\u000a\u000avoid surface(void);\u000avoid volume(void);\u000a\u000a\u000avoid main(void)\u000a{\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a	\u000a	surface();\u000a	volume();\u000a}\u000a
p416
sg51
I01
sbsg65
Vmain_vert
p417
sbag0
(g56
g2
Ntp418
Rp419
(dp420
g34
g275
sg45
g0
(g60
g2
Ntp421
Rp422
(dp423
g45
Vprecision highp float;\u000a\u000auniform samplerCube sky;\u000a\u000avarying vec3 colour;\u000a\u000avec4 surface(void);\u000avec4 volume(vec4);\u000a\u000a\u000avoid main(void)\u000a{\u000a	vec4 surf = surface();\u000a	vec4 vol = volume( surf );\u000a	gl_FragColor = vol;\u000a}\u000a
p424
sg51
I01
sbsg65
Vmain_frag
p425
sbag0
(g30
g2
Ntp426
Rp427
(dp428
g34
g275
sg35
V<h2>Display the scene</h2>
p429
sbag0
(g41
g2
Ntp430
Rp431
(dp432
g34
g275
sg45
g0
(g46
g2
Ntp433
Rp434
(dp435
g45
Vimport math\u000a\u000aimport numpy as np\u000a\u000afrom larch import webglscene\u000afrom britefury.pres.resource import ImageFromFile\u000a\u000a\u000aimport fractal_landscape\u000aimport ocean\u000aimport plot3d\u000a\u000a\u000a# Ocean function\u000adef make_ocean():\u000a    philips_spectrum = ocean.PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000a    o = ocean.Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000a    o.apply_philips(philips_spectrum)\u000a    \u000a    o.step(0.5)\u000a    o.update_heights()\u000a    \u000a    return o\u000a\u000a\u000a\u000a#\u000a# Sky textures\u000a#\u000a\u000asky_names = [\u000a             'testimages/skybox_east',\u000a             'testimages/skybox_west',\u000a             'testimages/skybox_down',\u000a             'testimages/skybox_up',\u000a             'testimages/skybox_south',\u000a             'testimages/skybox_north'\u000a             ]\u000a\u000asky_textures = [ImageFromFile('{0}.jpg'.format(n))   for n in sky_names]\u000a\u000a\u000a# Sky\u000asky = webglscene.Skybox(sky_textures)\u000a\u000a# Sky cubemap\u000asky_cube = webglscene.TextureCube(sky_textures)\u000a\u000a# Camera\u000acam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 150.0, 0.0, math.radians(30.0))\u000a\u000a\u000a\u000a#\u000a# Landscape material\u000a#\u000alandscape_material_plain = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_identity_vert], [main_frag + terrain_frag + vol_identity_frag]),\u000a	{'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000alandscape_material_oceanfog = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_oceanfog_vert], [main_frag + terrain_frag + vol_oceanfog_frag]),\u000a	{'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000a\u000a\u000alandscape_material = landscape_material_oceanfog\u000a\u000a\u000a# Landscape\u000alandscape_heightfield = fractal_landscape.fractal_heightfield(np.random.RandomState(2), 128, 100.0, 4, 32, 5.0, 0.3)\u000alandscape = plot3d.plot3d_entity(landscape_heightfield, 100.0, 100.0, material=landscape_material, generate_tex_coords=True)\u000a\u000a\u000a\u000a#\u000a# Ocean material\u000a#\u000a\u000aocean_material_plain = webglscene.Material(webglscene.Shader([main_vert + ocean_plain_vert + vol_identity_vert], [main_frag + ocean_plain_frag + vol_identity_frag]))\u000aocean_material_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_fresnel_frag + vol_identity_frag]),\u000a		{'sky': sky_cube})\u000aocean_material_trans_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_transparent_fresnel_frag + vol_identity_frag]),\u000a		{'sky': sky_cube}, use_blending=True)\u000aocean_material_trans_fresnel_oceanfog = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_oceanfog_forocean_vert], [main_frag + ocean_transparent_fresnel_frag + vol_oceanfog_transparent_frag]),\u000a		{'sky': sky_cube}, use_blending=True)\u000a\u000aocean_material = ocean_material_trans_fresnel_oceanfog\u000a\u000a\u000a# Ocean\u000aoc = make_ocean()\u000aoc3d = plot3d.plot3d_entity(oc.heights, oc.size, oc.size, material=ocean_material)\u000a\u000a\u000a# Scene on canvas\u000awebglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape, oc3d]))\u000a#webglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape]))\u000a
p436
sg51
I01
sbsbasbsg16
VCool_Demo
p437
sg80
I5
sbasb.