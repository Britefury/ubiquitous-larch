ccopy_reg
_reconstructor
p0
(clarch.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
g0
(clarch.project.project_page
ProjectPage
p19
g2
Ntp20
Rp21
(dp22
S'data'
p23
g0
(clarch.worksheet.worksheet
Worksheet
p24
g2
Ntp25
Rp26
(dp27
S'blocks'
p28
(lp29
g0
(clarch.worksheet.worksheet
WorksheetBlockText
p30
g2
Ntp31
Rp32
(dp33
S'worksheet'
p34
g26
sS'text'
p35
V<h1>WebGL Canvas</h1><p>First, we implement the Javascript code that renders objects using WebGL:</p>
p36
sbag0
(clarch.worksheet.worksheet
WorksheetBlockSource
p37
g2
Ntp38
Rp39
(dp40
g34
g26
sS'code'
p41
g0
(clarch.source_code
JSCode
p42
g2
Ntp43
Rp44
(dp45
g41
Vfunction degToRad(deg) {\u000a    return deg * (Math.PI/180.0);\u000a}\u000a\u000a\u000afunction GLCanvas(glc, canvas) {\u000a    glc.canvas = canvas;\u000a    glc.gl = null;\u000a    \u000a    try {\u000a        glc.gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");\u000a    }\u000a    catch (e) {\u000a        console.log("Caught " + e + " when initialising webgl");\u000a    }\u000a    \u000a    glc.redraw = function() {\u000a        glc.draw(glc);\u000a    }\u000a}\u000a\u000a\u000a\u000afunction ShaderCanvas(glc, canvas, vsSource, fsSource) {\u000a    GLCanvas(glc, canvas);\u000a\u000a    var gl = glc.gl;\u000a    \u000a    if (gl) {\u000a    	//\u000a        // SHADERS\u000a        //\u000a        \u000a        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\u000a        gl.shaderSource(vertexShader, vsSource);\u000a        gl.compileShader(vertexShader);\u000a        \u000a        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\u000a            alert("Vertex shader compile failed " + gl.getShaderInfoLog(vertexShader));\u000a        }\u000a        \u000a        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\u000a        gl.shaderSource(fragmentShader, fsSource);\u000a        gl.compileShader(fragmentShader);\u000a        \u000a        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\u000a            alert("Fragment shader compile failed " + gl.getShaderInfoLog(fragmentShader));\u000a        }\u000a        \u000a        var shaderProgram = gl.createProgram();\u000a        gl.attachShader(shaderProgram, vertexShader);\u000a        gl.attachShader(shaderProgram, fragmentShader);\u000a        gl.linkProgram(shaderProgram);\u000a        \u000a        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\u000a            alert("Unable to link the shader program.");\u000a        }        \u000a        \u000a        gl.useProgram(shaderProgram);\u000a        glc.shaderProgram = shaderProgram;\u000a    }\u000a}\u000a\u000a\u000afunction TurntableCanvas(glc, canvas, vsSource, fsSource, fovY, nearFrac, farFrac, focalPoint, orbitalRadius, azimuth, altitude) {\u000a    ShaderCanvas(glc, canvas, vsSource, fsSource);\u000a    \u000a    \u000a    glc.fovY = fovY;\u000a    glc.aspectRatio = canvas.width/canvas.height;\u000a    glc.nearFrac = nearFrac;\u000a    glc.farFrac = farFrac;\u000a    glc.focalPoint = focalPoint;\u000a    glc.orbitalRadius = orbitalRadius;\u000a    glc.azimuth = azimuth;\u000a    glc.altitude = altitude;\u000a    glc._navFunction = null;\u000a    glc._navPos = null;\u000a    \u000a    canvas.onmousedown = function(evt) {\u000a        if (evt.altKey) {\u000a            glc._navFunction = evt.button;\u000a            glc._navPos = [evt.offsetX, evt.offsetY];\u000a            return false;\u000a        }\u000a        else {\u000a            return true;\u000a        }\u000a        \u000a    }\u000a        \u000a    canvas.onmouseup = function(evt) {\u000a        glc._navFunction = null;\u000a    }\u000a            \u000a    canvas.onmousemove = function(evt) {\u000a        if (glc._navFunction !== null) {\u000a            var dx = evt.offsetX - glc._navPos[0];\u000a            var dy = glc._navPos[1] - evt.offsetY;\u000a            \u000a            if (glc._navFunction === 0) {\u000a                glc.rotate(-dx * 0.01, -dy * 0.01);\u000a                glc.redraw();\u000a            }\u000a            else if (glc._navFunction === 1) {\u000a            } \u000a            else if (glc._navFunction === 2) {\u000a                glc.zoom(Math.pow(Math.pow(2.0,0.005), -dx));\u000a                glc.redraw();\u000a            }\u000a            glc._navPos = [evt.offsetX, evt.offsetY];\u000a        }\u000a    }\u000a    \u000a    glc.apply = function(gl) {\u000a        var near = glc.nearFrac * glc.orbitalRadius;\u000a        var far = glc.farFrac * glc.orbitalRadius;\u000a        \u000a        var projectionMatrix = mat4.create();\u000a        mat4.perspective(projectionMatrix, fovY, glc.aspectRatio, near, far);\u000a        \u000a        // Camera matrix\u000a        var cameraMatrix = glc._createWorldToCameraMatrix();\u000a        //cameraMatrix = mat4.create();\u000a        //mat4.lookAt(cameraMatrix, [0.0, 6.0*Math.sin(degToRad(30.0)), -6.0*Math.cos(degToRad(30.0))], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]); \u000a        \u000a        \u000a        var pUniform = gl.getUniformLocation(glc.shaderProgram, "projectionMatrix");\u000a        gl.uniformMatrix4fv(pUniform, false, new Float32Array(projectionMatrix));\u000a        \u000a        var mvUniform = gl.getUniformLocation(glc.shaderProgram, "cameraMatrix");\u000a        gl.uniformMatrix4fv(mvUniform, false, new Float32Array(cameraMatrix));\u000a    }\u000a        \u000a    glc._createWorldToCameraMatrix = function() {\u000a        var cameraMatrix = mat4.create();\u000a	    var invPos = vec3.create();\u000a        vec3.negate(invPos, glc.focalPoint);\u000a        \u000a        // Move the world and camera so that the camera lies at the origin\u000a        mat4.translate(cameraMatrix, cameraMatrix, [0.0, 0.0, -glc.orbitalRadius]);\u000a        \u000a        // Rotate the world so that the camera lies on the forward axis\u000a        mat4.rotateY(cameraMatrix, cameraMatrix, -glc.azimuth);\u000a        \u000a        // Rotate the world and camera so that the camera rests on the XZ plane\u000a        mat4.rotateX(cameraMatrix, cameraMatrix, glc.altitude);\u000a        \u000a        // Move the focal point to the centre of the world\u000a        mat4.translate(cameraMatrix, cameraMatrix, invPos);\u000a\u000a        return cameraMatrix;\u000a    }\u000a        \u000a    glc._createCameraToWorldRotationMatrix = function() {\u000a        // Inverse of _createWorldToCameraMatrix(), but rotations only\u000a        var cameraMatrix = mat3.create();\u000a        \u000a        mat3.rotateY(cameraMatrix, cameraMatrix, glc.azimuth);\u000a        mat3.rotateX(cameraMatrix, cameraMatrix, -glc.altitude);\u000a        \u000a        return cameraMatrix;\u000a    }        \u000a        \u000a        \u000a    glc.translate = function(translation) {\u000a        vec3.add(glc.focalPoint, glc.focalPoint, translation);\u000a    }\u000a        \u000a    glc.zoom = function(zoomFactor) {\u000a        glc.orbitalRadius *= zoomFactor;\u000a    }\u000a           \u000a    glc.rotate = function(azimuth, altitude) {\u000a        glc.azimuth = (this.azimuth + azimuth) % Math.PI;\u000a        glc.altitude += altitude;\u000a        glc.altitude = Math.min(Math.max(glc.altitude, -Math.PI*0.5), Math.PI*0.5);\u000a    }\u000a    \u000a    glc.pan = function(translationInCameraSpace) {\u000a        var camRot = glc._createCameraToWorldRotationMatrix();\u000a        var translationInWorldSpace = vec3.create();\u000a        vec3.transformMat3(translationInWorldSpace, translationInCameraSpace, camRot);\u000a        \u000a		glc.translate(translationInWorldSpace);\u000a    }        \u000a}\u000a\u000a\u000a\u000afunction MeshCanvas(glc, canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, indexBufferModesData) {\u000a    TurntableCanvas(glc, canvas, vsSource, fsSource, fovY, 0.01, 100.0, focalPoint, orbitalRadius, degToRad(0.0), degToRad(30.0));\u000a    \u000a	var gl = glc.gl;\u000a    \u000a\u000a    gl.useProgram(glc.shaderProgram);\u000a        \u000a\u000a    //\u000a    // CREATE VERTICES BUFFER\u000a    //\u000a    \u000a    var verticesBuffer = gl.createBuffer();\u000a    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\u000a    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\u000a    glc.verticesBuffer = verticesBuffer;\u000a    \u000a    \u000a    \u000a    //\u000a    // GET ATTRIBUTE LOCATIONS\u000a	//\u000a    \u000a    var attribLocations = [];\u000a    var attribSizes = [];\u000a    var attribStride = 0;\u000a    for (var i = 0; i < vertexAttribNamesSizes.length; i++) {\u000a        var loc = gl.getAttribLocation(glc.shaderProgram, vertexAttribNamesSizes[i][0]);\u000a        gl.enableVertexAttribArray(loc);\u000a        \u000a        attribLocations.push(loc);\u000a        var sz = vertexAttribNamesSizes[i][1];\u000a        attribSizes.push(sz);\u000a        attribStride += sz;\u000a    }\u000a    glc.attribLocations = attribLocations;\u000a    glc.attribSizes = attribSizes;\u000a    glc.attribStride = attribStride;\u000a    \u000a    \u000a    \u000a    //\u000a    // CREATE INDICES BUFFER\u000a    //\u000a    \u000a    var indexBuffers = [];\u000a    var indexBufferModes = [];\u000a    var indexBufferSizes = [];\u000a    \u000a    var _modeNameToMode = {\u000a        points: gl.POINTS,\u000a        line_strip: gl.LINE_STRIP,\u000a        line_loop: gl.LINE_LOOP,\u000a        lines: gl.LINES,\u000a        triangle_strip: gl.TRIANGLE_STRIP,\u000a        triangle_fan: gl.TRIANGLE_FAN,\u000a        triangles: gl.TRIANGLES,\u000a    };\u000a    \u000a    for (var i = 0; i < indexBufferModesData.length; i++) {\u000a        var mode = _modeNameToMode[indexBufferModesData[i][0]];\u000a        var indices = indexBufferModesData[i][1];\u000a        var indicesBuffer = gl.createBuffer();\u000a        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\u000a        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\u000a        indexBuffers.push(indicesBuffer);\u000a        indexBufferModes.push(mode);\u000a        indexBufferSizes.push(indices.length);\u000a    }\u000a    glc.indexBuffers = indexBuffers;\u000a    glc.indexBufferModes = indexBufferModes;\u000a    glc.indexBufferSizes = indexBufferSizes;\u000a    \u000a    \u000a       \u000a    \u000a    function draw(glc) {\u000a        var gl = glc.gl;\u000a        \u000a        gl.clearColor(0.0, 0.0, 0.0, 1.0);\u000a        gl.enable(gl.DEPTH_TEST);\u000a        gl.depthFunc(gl.LEQUAL);\u000a        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\u000a        \u000a        gl.useProgram(glc.shaderProgram);\u000a        \u000a        // Apply camera\u000a        glc.apply(gl);\u000a\u000a        \u000a        //\u000a        // OBJECT\u000a        //\u000a        \u000a        gl.bindBuffer(gl.ARRAY_BUFFER, glc.verticesBuffer);\u000a        var offset = 0;\u000a        for (var i = 0; i < glc.attribLocations.length; i++) {\u000a            gl.vertexAttribPointer(glc.attribLocations[i], glc.attribSizes[i], gl.FLOAT, false, glc.attribStride*4, offset*4);\u000a            offset += glc.attribSizes[i];\u000a        }\u000a        \u000a        for (var i = 0; i < glc.indexBuffers.length; i++) {\u000a	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glc.indexBuffers[i]);\u000a	        gl.drawElements(glc.indexBufferModes[i], glc.indexBufferSizes[i], gl.UNSIGNED_SHORT, 0);\u000a        }\u000a		        \u000a    }\u000a    \u000a    glc.draw = draw;\u000a}\u000a\u000a\u000a\u000a\u000a\u000a\u000afunction UVMeshCanvas(glc, canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, width, height, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData) {\u000a    TurntableCanvas(glc, canvas, vsSource, fsSource, fovY, 0.01, 100.0, focalPoint, orbitalRadius, degToRad(0.0), degToRad(30.0));\u000a	var gl = glc.gl;\u000a    \u000a\u000a    gl.useProgram(glc.shaderProgram);\u000a    \u000a    \u000a    //\u000a    // Convert incoming arrays to Float32Arrays\u000a    // Compute total vertex size\u000a    //\u000a	vertexPositions = new Float32Array(vertexPositions);\u000a    var vertexSize = 6;		// Account for position and normal\u000a    for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a        vertexSize += vertexAttribsNamesSizesData[i][1];\u000a        vertexAttribsNamesSizesData[i][2] = new Float32Array(vertexAttribsNamesSizesData[i][2]);\u000a    }\u000a    \u000a    \u000a    \u000a    //\u000a    // ASSEMBLE VERTEX ARRAY\u000a    //\u000a        \u000a    var bufferSize = vertexSize * width * height;\u000a    var vertices = new Float32Array(bufferSize);\u000a\u000a    for (var y = 0; y < height; y++) {\u000a        for (var x = 0; x < width; x++) {\u000a            // Vertex position\u000a            var ndx = x+y*width;\u000a            var pos = [vertexPositions[ndx*3], vertexPositions[ndx*3+1], vertexPositions[ndx*3+2]];\u000a\u000a            // Get adjacent vertices and compute normal\u000a            var ixp = x > 0  ?  x - 1  :  (closedU ? width - 1 : 0);			// X-prev\u000a            var ixn = x < width - 1  ?  x + 1  :  (closedU ? 0 : width - 1);	// X-next\u000a            var iyp = y > 0  ?  y - 1  :  (closedV ? height - 1 : 0);			// Y-prev\u000a            var iyn = y < height - 1  ?  y + 1  :  (closedV ? 0 : height - 1);	// Y-next\u000a            var vxp = [vertexPositions[(ixp+y*width)*3], vertexPositions[(ixp+y*width)*3+1], vertexPositions[(ixp+y*width)*3+2]];\u000a            var vxn = [vertexPositions[(ixn+y*width)*3], vertexPositions[(ixn+y*width)*3+1], vertexPositions[(ixn+y*width)*3+2]];\u000a            var vyp = [vertexPositions[(x+iyp*width)*3], vertexPositions[(x+iyp*width)*3+1], vertexPositions[(x+iyp*width)*3+2]];\u000a            var vyn = [vertexPositions[(x+iyn*width)*3], vertexPositions[(x+iyn*width)*3+1], vertexPositions[(x+iyn*width)*3+2]];\u000a            var u = [vxn[0] - vxp[0], vxn[1] - vxp[1], vxn[2] - vxp[2]];\u000a            var v = [vyn[0] - vyp[0], vyn[1] - vyp[1], vyn[2] - vyp[2]];\u000a            var n = [u[1] * v[2] - u[2] * v[1],   u[2] * v[0] - u[0] * v[2],   u[0] * v[1] - u[1] * v[0]];\u000a            var nlen = Math.sqrt(n[0]*n[0]  +  n[1]*n[1]  +  n[2]*n[2]);\u000a            var invl = nlen == 0.0  ?  1.0  :  1.0 / nlen;\u000a            n = [n[0]*invl, n[1]*invl, n[2]*invl];\u000a            \u000a            // Add to array\u000a            var offset = ndx*vertexSize;\u000a            vertices[offset] = pos[0];\u000a            vertices[offset+1] = pos[1];\u000a            vertices[offset+2] = pos[2];\u000a            vertices[offset+3] = n[0];\u000a            vertices[offset+4] = n[1];\u000a            vertices[offset+5] = n[2];\u000a            \u000a            offset += 6;\u000a            // Deal with remaining attributes\u000a            for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a                var sz = vertexAttribsNamesSizesData[i][1];\u000a                for (var j = 0; j < sz; j++) {\u000a                    vertices[offset+j] = vertexAttribsNamesSizesData[i][2][ndx*sz+j];\u000a                }\u000a                offset += sz;\u000a            }\u000a        }\u000a    }\u000a        \u000a\u000a    //\u000a    // CREATE VERTICES BUFFER\u000a    //\u000a    \u000a    var verticesBuffer = gl.createBuffer();\u000a    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);\u000a    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\u000a    glc.verticesBuffer = verticesBuffer;\u000a    \u000a    \u000a    \u000a    //\u000a    // GET ATTRIBUTE LOCATIONS\u000a	//\u000a    \u000a    var attribLocations = [];\u000a    var attribSizes = [];\u000a        \u000a    // Handle position and normal first\u000a    \u000a    var vertexPosLoc = gl.getAttribLocation(glc.shaderProgram, "vertexPos");\u000a    gl.enableVertexAttribArray(vertexPosLoc);\u000a    attribLocations.push(vertexPosLoc);\u000a    attribSizes.push(3);\u000a    \u000a    var vertexNrmLoc = gl.getAttribLocation(glc.shaderProgram, "vertexNrm");\u000a    gl.enableVertexAttribArray(vertexNrmLoc);\u000a    attribLocations.push(vertexNrmLoc);\u000a    attribSizes.push(3);\u000a    \u000a    var attribStride = 6;\u000a        \u000a    // Now handle remaining attributes\u000a    \u000a    for (var i = 0; i < vertexAttribsNamesSizesData.length; i++) {\u000a        var loc = gl.getAttribLocation(glc.shaderProgram, vertexAttribsNamesSizesData[i][0]);\u000a        gl.enableVertexAttribArray(loc);\u000a        \u000a        attribLocations.push(loc);\u000a        var sz = vertexAttribsNamesSizesData[i][1];\u000a        attribSizes.push(sz);\u000a        attribStride += sz;\u000a    }\u000a    glc.attribLocations = attribLocations;\u000a    glc.attribSizes = attribSizes;\u000a    glc.attribStride = attribStride;\u000a    \u000a    \u000a    \u000a    //\u000a    // CREATE INDICES BUFFER\u000a    //\u000a    \u000a    var numRows = closedV  ?  height  :  height - 1;\u000a    var numColumns = closedU  ?  width  :  width - 1;\u000a    var indices = new Uint16Array(numRows*numColumns*6);\u000a    \u000a	var ndx = 0;\u000a    for (var y = 0; y < (height-1); y++) {\u000a        for (var x = 0; x < (width-1); x++) {\u000a            var a = y*width + x;\u000a            var b = a+1;\u000a            var c = a+width;\u000a            var d = c+1;\u000a            indices[ndx] = a;\u000a            indices[ndx+1] = b;\u000a            indices[ndx+2] = c;\u000a            indices[ndx+3] = b;\u000a            indices[ndx+4] = d;\u000a            indices[ndx+5] = c;\u000a            ndx += 6;\u000a    	}\u000a        if (closedU) {\u000a            var a = y*width + width-1;\u000a            var b = y*width;\u000a            var c = a+width;\u000a            var d = b+width;\u000a            indices[ndx] = a;\u000a            indices[ndx+1] = b;\u000a            indices[ndx+2] = c;\u000a            indices[ndx+3] = b;\u000a            indices[ndx+4] = d;\u000a            indices[ndx+5] = c;\u000a            ndx += 6;\u000a        }\u000a    }\u000a    if (closedV) {\u000a        for (var x = 0; x < (width-1); x++) {\u000a            var a = (height-1)*width + x;\u000a            var b = a+1;\u000a            var c = x;\u000a            var d = c+1;\u000a            indices[ndx] = a;\u000a            indices[ndx+1] = b;\u000a            indices[ndx+2] = c;\u000a            indices[ndx+3] = b;\u000a            indices[ndx+4] = d;\u000a            indices[ndx+5] = c;\u000a            ndx += 6;\u000a    	}\u000a        if (closedU) {\u000a            var a = (height-1)*width + width-1;\u000a            var b = (height-1)*width;\u000a            var c = width-1;\u000a            var d = 0;\u000a            indices[ndx] = a;\u000a            indices[ndx+1] = b;\u000a            indices[ndx+2] = c;\u000a            indices[ndx+3] = b;\u000a            indices[ndx+4] = d;\u000a            indices[ndx+5] = c;\u000a            ndx += 6;\u000a        }\u000a    }\u000a    \u000a    \u000a    for (var i = 0; i < indices.length; i+=6) {\u000a    	var s = "";\u000a        for (var j = 0; j < 6; j++) {\u000a            s += (indices[i+j] + ",");\u000a        }\u000a        console.log(s);\u000a    }\u000a    \u000a    \u000a    var indexBuffer = gl.createBuffer();\u000a    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\u000a    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\u000a    glc.indexBuffer = indexBuffer;\u000a    glc.numElements = indices.length;\u000a    \u000a    \u000a       \u000a    \u000a    function draw(glc) {\u000a        var gl = glc.gl;\u000a        \u000a        gl.clearColor(0.0, 0.0, 0.0, 1.0);\u000a        gl.enable(gl.DEPTH_TEST);\u000a        gl.depthFunc(gl.LEQUAL);\u000a        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\u000a        \u000a        gl.useProgram(glc.shaderProgram);\u000a        \u000a        // Apply camera\u000a        glc.apply(gl);\u000a\u000a        \u000a        //\u000a        // OBJECT\u000a        //\u000a        \u000a        gl.bindBuffer(gl.ARRAY_BUFFER, glc.verticesBuffer);\u000a        var offset = 0;\u000a        for (var i = 0; i < glc.attribLocations.length; i++) {\u000a            gl.vertexAttribPointer(glc.attribLocations[i], glc.attribSizes[i], gl.FLOAT, false, glc.attribStride*4, offset*4);\u000a            offset += glc.attribSizes[i];\u000a        }\u000a        \u000a        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glc.indexBuffer);\u000a        gl.drawElements(gl.TRIANGLES, glc.numElements, gl.UNSIGNED_SHORT, 0);\u000a    }\u000a    \u000a    glc.draw = draw;\u000a}\u000a\u000a\u000afunction test_mesh_canvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, indices) {\u000a    var glc = {};\u000a    MeshCanvas(glc, canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, indices);\u000a    glc.redraw();\u000a}\u000a\u000a\u000afunction test_uvmesh_canvas(canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, width, height, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData) {\u000a    var glc = {};\u000a    UVMeshCanvas(glc, canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, width, height, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData);\u000a    glc.redraw();\u000a}\u000a\u000a\u000a\u000a    \u000a
p46
sS'editable'
p47
I01
sbsS'var_name'
p48
Vinitwebgl_js
p49
sbag0
(g30
g2
Ntp50
Rp51
(dp52
g34
g26
sg35
V<p>Now, we define a fragment shader:</p>
p53
sbag0
(g37
g2
Ntp54
Rp55
(dp56
g34
g26
sg41
g0
(clarch.source_code
GLSLCode
p57
g2
Ntp58
Rp59
(dp60
g41
Vprecision mediump float;\u000a\u000avarying vec3 colour;\u000a\u000avoid main(void) {\u000a    gl_FragColor = vec4(colour, 1.0)*0.5+0.5;\u000a}
p61
sg47
I01
sbsg48
Vfs_glsl
p62
sbag0
(g30
g2
Ntp63
Rp64
(dp65
g34
g26
sg35
V<p>Now a&nbsp;vertex shader:</p>
p66
sbag0
(g37
g2
Ntp67
Rp68
(dp69
g34
g26
sg41
g0
(g57
g2
Ntp70
Rp71
(dp72
g41
Vattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000a\u000avarying vec3 colour;\u000a  \u000a\u000avoid main(void) {\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a    colour = vec3(dot(vertexNrm, vec3(0,1,0)));\u000a}\u000a
p73
sg47
I01
sbsg48
Vvs_glsl
p74
sbag0
(g30
g2
Ntp75
Rp76
(dp77
g34
g26
sg35
V<p>Finally, we test:</p>
p78
sbag0
(clarch.worksheet.worksheet
WorksheetBlockCode
p79
g2
Ntp80
Rp81
(dp82
g34
g26
sg41
g0
(clarch.source_code
PythonCode
p83
g2
Ntp84
Rp85
(dp86
g41
Vimport math\u000afrom britefury.pres.html import Html\u000a\u000a\u000a\u000adef make_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices\u000a  \u000a    \u000adef make_uv_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices\u000a        \u000a\u000a\u000a\u000a\u000a\u000adef gl_canvas(width, height):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, indices\u000a\u000a    #vertices, indices = make_torus(4.0, 32, 1.0, 16)\u000a    #return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a    #      'test_mesh_canvas', vs_glsl, fs_glsl, 45.0, [0.0, 0.0, 0.0], 12.0, [['vertexPos', 3], ['vertexNrm', 3]], vertices, [['triangles', indices]]).use_js(source=initwebgl_js).use_js(url='/gl-matrix-min.js')\u000a\u000a    vertices = make_uv_torus(4.0, 32, 1.0, 16)\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'test_uvmesh_canvas', vs_glsl, fs_glsl, 45.0, [0.0, 0.0, 0.0], 12.0, 16, 32, True, True, vertices, []).use_js(source=initwebgl_js).use_js(url='/gl-matrix-min.js')\u000a\u000agl_canvas(800,600)
p87
sg47
I01
sbsbasbsg16
Vwebgl_canvas
p88
sS'id'
p89
I0
sbasbasb.