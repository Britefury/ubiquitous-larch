ccopy_reg
_reconstructor
p0
(clarch.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
g0
(clarch.project.project_page
ProjectPage
p19
g2
Ntp20
Rp21
(dp22
S'data'
p23
g0
(clarch.worksheet.worksheet
Worksheet
p24
g2
Ntp25
Rp26
(dp27
S'blocks'
p28
(lp29
g0
(clarch.worksheet.worksheet
WorksheetBlockText
p30
g2
Ntp31
Rp32
(dp33
S'worksheet'
p34
g26
sS'text'
p35
V<h1>WebGL Canvas</h1><p>First, we implement the Javascript code that renders objects using WebGL:</p>
p36
sbag0
(g30
g2
Ntp37
Rp38
(dp39
g34
g26
sg35
V<p>Define WebGL canvas Python functions:</p>
p40
sbag0
(clarch.worksheet.worksheet
WorksheetBlockCode
p41
g2
Ntp42
Rp43
(dp44
g34
g26
sS'code'
p45
g0
(clarch.source_code
PythonCode
p46
g2
Ntp47
Rp48
(dp49
g45
Vfrom britefury.pres.html import Html\u000a\u000a\u000adef gl_canvas_with_literal_mesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, vertexAttribNamesSizes, vertices, modesAndIndices\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, vertex_attrib_names_sizes, vertices, modes_indices).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_literal_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, uSegs, vSegs, closedU, closedV, vertexPositions, vertexAttribsNamesSizesData\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'LiteralUVMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, u_segs, v_segs, u_closed, v_closed, vertex_positions, vertex_attribs_names_sizes_data).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a    \u000a\u000adef gl_canvas_with_rsc_uvmesh(width, height, vs_source, fs_source, fov_y, focal_point, orbital_radius, resource):\u000a    # canvas, vsSource, fsSource, fovY, focalPoint, orbitalRadius, resource\u000a    return Html('<canvas width="{0}" height="{1}"></canvas>'.format(width, height)).js_function_call(\u000a          'ResourceUVMeshCanvas', vs_source, fs_source, fov_y, focal_point, orbital_radius, resource).use_js(url='/webglscene.js').use_js(url='/gl-matrix-min.js')\u000a
p50
sS'editable'
p51
I01
sbsbag0
(g30
g2
Ntp52
Rp53
(dp54
g34
g26
sg35
V<h1>Plain white shader</h1><p>Fragment:</p>
p55
sbag0
(clarch.worksheet.worksheet
WorksheetBlockSource
p56
g2
Ntp57
Rp58
(dp59
g34
g26
sg45
g0
(clarch.source_code
GLSLCode
p60
g2
Ntp61
Rp62
(dp63
g45
Vprecision mediump float;\u000a\u000avarying vec3 colour;\u000a\u000avoid main(void) {\u000a    gl_FragColor = vec4(colour, 1.0)*0.5+0.5;\u000a}
p64
sg51
I01
sbsS'var_name'
p65
Vplainwhite_fshader
p66
sbag0
(g30
g2
Ntp67
Rp68
(dp69
g34
g26
sg35
V<p>Vertex:</p>
p70
sbag0
(g56
g2
Ntp71
Rp72
(dp73
g34
g26
sg45
g0
(g60
g2
Ntp74
Rp75
(dp76
g45
Vattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000a\u000avarying vec3 colour;\u000a  \u000a\u000avoid main(void) {\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a    colour = vec3(dot(vertexNrm, vec3(0,1,0)));\u000a}
p77
sg51
I01
sbsg65
Vplainwhite_vshader
p78
sbasbsg16
Vwebgl_canvas
p79
sS'id'
p80
I0
sbasbag0
(g12
g2
Ntp81
Rp82
(dp83
g16
VExamples
p84
sg10
(lp85
g0
(g19
g2
Ntp86
Rp87
(dp88
g23
g0
(g24
g2
Ntp89
Rp90
(dp91
g28
(lp92
g0
(g30
g2
Ntp93
Rp94
(dp95
g34
g90
sg35
V<h1>Torus examples</h1><p>First, import the uv mesh stuff:</p>
p96
sbag0
(g41
g2
Ntp97
Rp98
(dp99
g34
g90
sg45
g0
(g46
g2
Ntp100
Rp101
(dp102
g45
Vimport math\u000a\u000afrom britefury.live.live_function import LiveFunction\u000afrom britefury.live.live_value import LiveValue\u000afrom britefury.pres.resource import JsonLiveFnResource\u000afrom britefury.pres.controls import slider\u000a\u000afrom Lib.webgl_canvas import *
p103
sg51
I01
sbsbag0
(g30
g2
Ntp104
Rp105
(dp106
g34
g90
sg35
V<h1>Building a torus</h1><p>We need to build a torus in two ways; as a mesh, and as a UV mesh where the structure of the model is implicit. Mesh first (generate both vertices and indices):</p>
p107
sbag0
(g41
g2
Ntp108
Rp109
(dp110
g34
g90
sg45
g0
(g46
g2
Ntp111
Rp112
(dp113
g45
Vdef mesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices
p114
sg51
I01
sbsbag0
(g30
g2
Ntp115
Rp116
(dp117
g34
g90
sg35
V<p>Now for the UV mesh:</p>
p118
sbag0
(g41
g2
Ntp119
Rp120
(dp121
g34
g90
sg45
g0
(g46
g2
Ntp122
Rp123
(dp124
g45
Vdef uvmesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices
p125
sg51
I01
sbsbag0
(g30
g2
Ntp126
Rp127
(dp128
g34
g90
sg35
V<h1>Example: mesh torus</h1>
p129
sbag0
(g41
g2
Ntp130
Rp131
(dp132
g34
g90
sg45
g0
(g46
g2
Ntp133
Rp134
(dp135
g45
Vmesh_verts, mesh_indices = mesh_torus(4.0, 32, 1.0, 16)\u000agl_canvas_with_literal_mesh(800, 600, plainwhite_vshader, plainwhite_fshader, 45.0, [0.0, 0.0, 0.0], 12.0, [['vertexPos', 3], ['vertexNrm', 3]], mesh_verts, [['triangles', mesh_indices]])
p136
sg51
I01
sbsbag0
(g30
g2
Ntp137
Rp138
(dp139
g34
g90
sg35
V<p>Example: UV mesh torus</p>
p140
sbag0
(g41
g2
Ntp141
Rp142
(dp143
g34
g90
sg45
g0
(g46
g2
Ntp144
Rp145
(dp146
g45
Vuvmesh_vertpos = uvmesh_torus(4.0, 32, 1.0, 16)\u000agl_canvas_with_literal_uvmesh(800, 600, plainwhite_vshader, plainwhite_fshader, 45.0, [0.0, 0.0, 0.0], 12.0, 16, 32, True, True, uvmesh_vertpos, [])
p147
sg51
I01
sbsbag0
(g30
g2
Ntp148
Rp149
(dp150
g34
g90
sg35
V<h1>Example: UV mesh torus as resource</h1>
p151
sbag0
(g41
g2
Ntp152
Rp153
(dp154
g34
g90
sg45
g0
(g46
g2
Ntp155
Rp156
(dp157
g45
Vmaj_rad = LiveValue(40)\u000amin_rad = LiveValue(10) \u000amaj_segs = LiveValue(32)\u000amin_segs = LiveValue(16) \u000a\u000a\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef torus_rsc():\u000a    vertices = uvmesh_torus(float(maj_rad.value)*0.1, maj_segs.value, float(min_rad.value)*0.1, min_segs.value)\u000a    return {\u000a            'uSegs': min_segs.value,\u000a            'vSegs': maj_segs.value,\u000a            'closedU': True,\u000a            'closedV': True,\u000a            'vertexPositions': vertices,\u000a            'vertexAttribsNamesSizesData': []\u000a            }\u000a\u000a\u000amaj_rad_slider = slider.live_slider(maj_rad, True)\u000amin_rad_slider = slider.live_slider(min_rad, True)\u000a\u000amaj_segs_slider = slider.live_slider(maj_segs, True)\u000amin_segs_slider = slider.live_slider(min_segs, True)\u000a\u000acanvas = gl_canvas_with_rsc_uvmesh(800, 600, plainwhite_vshader, plainwhite_fshader, 45.0, [0.0, 0.0, 0.0], 12.0, torus_rsc)\u000aHtml(canvas, '<br>Major radius: ', maj_rad_slider, 'Major segments: ', maj_segs_slider, 'Minor radius: ', min_rad_slider, 'Minor segments: ', min_segs_slider)
p158
sg51
I01
sbsbasbsg16
VTorusExamples
p159
sg80
I1
sbasbag0
(g19
g2
Ntp160
Rp161
(dp162
g23
g0
(g24
g2
Ntp163
Rp164
(dp165
g28
(lp166
g0
(g30
g2
Ntp167
Rp168
(dp169
g34
g164
sg35
V<h1>3D Plotting</h1><p>Imports first:</p>
p170
sbag0
(g41
g2
Ntp171
Rp172
(dp173
g34
g164
sg45
g0
(g46
g2
Ntp174
Rp175
(dp176
g45
Vfrom britefury.live.live_function import LiveFunction\u000afrom britefury.live.live_value import LiveValue\u000afrom britefury.pres.resource import JsonLiveFnResource\u000afrom britefury.pres.controls import slider\u000a\u000a\u000afrom Lib.webgl_canvas import *
p177
sg51
I01
sbsbag0
(g30
g2
Ntp178
Rp179
(dp180
g34
g164
sg35
V<p>Now define 3D plotting function:</p>
p181
sbag0
(g41
g2
Ntp182
Rp183
(dp184
g34
g164
sg45
g0
(g46
g2
Ntp185
Rp186
(dp187
g45
Vdef plot3d(data, width, depth, canvas_width=800, canvas_height=600, vs_source=plainwhite_vshader, fs_source=plainwhite_fshader):\u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    for row in data:\u000a        x = width * -0.5\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a        z += delta_z\u000a        \u000a    focal_y = (min_y + max_y) * 0.5\u000a    \u000a    dim = max(width, depth, max_y - min_y)\u000a    \u000a    return gl_canvas_with_literal_uvmesh(canvas_width, canvas_height, vs_source, fs_source, 45.0, [0.0, focal_y, 0.0], dim * 1.5, u_segs, v_segs, False, False, vertex_positions, [])\u000a\u000a\u000a\u000adef plot3d_live(data_live, width, depth, canvas_width=800, canvas_height=600, vs_source=plainwhite_vshader, fs_source=plainwhite_fshader):\u000a    @JsonLiveFnResource\u000a    @LiveFunction\u000a    def plot_rsc():\u000a        data = data_live.value\u000a        \u000a        v_segs = len(data)\u000a        u_segs = len(data[0])\u000a        \u000a        vertex_positions = []\u000a        \u000a        delta_z = depth / v_segs\u000a        delta_x = width / u_segs\u000a    \u000a        z = depth * -0.5\u000a        for row in data:\u000a            x = width * -0.5\u000a            for col in row:\u000a                vertex_positions.extend([x, col, z])\u000a                x += delta_x\u000a            z += delta_z\u000a\u000a        return {\u000a                'uSegs': u_segs,\u000a                'vSegs': v_segs,\u000a                'closedU': False,\u000a                'closedV': False,\u000a                'vertexPositions': vertex_positions,\u000a                'vertexAttribsNamesSizesData': []\u000a                }\u000a    \u000a    dim = max(width, depth)\u000a    \u000a    return gl_canvas_with_rsc_uvmesh(canvas_width, canvas_height, vs_source, fs_source, 45.0, [0.0, 0.0, 0.0], dim * 1.5, plot_rsc)\u000a\u000a\u000a\u000a
p188
sg51
I01
sbsbag0
(g30
g2
Ntp189
Rp190
(dp191
g34
g164
sg35
V<p>Test (literal first):</p>
p192
sbag0
(g41
g2
Ntp193
Rp194
(dp195
g34
g164
sg45
g0
(g46
g2
Ntp196
Rp197
(dp198
g45
Vplot3d([[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)], 100.0, 100.0)
p199
sg51
I01
sbsbag0
(g30
g2
Ntp200
Rp201
(dp202
g34
g164
sg35
V<p>Now live data:</p>
p203
sbag0
(g41
g2
Ntp204
Rp205
(dp206
g34
g164
sg45
g0
(g46
g2
Ntp207
Rp208
(dp209
g45
Vu_scale = LiveValue(10)\u000av_scale = LiveValue(10) \u000a\u000a\u000a@LiveFunction\u000adef data():\u000a    us = u_scale.value*0.01\u000a    vs = v_scale.value*0.01\u000a    return [[float(((i-8)**2)*us+((j-8)**2))*vs   for i in xrange(16)] for j in xrange(16)]\u000a    #return [[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)]\u000a\u000au_slider = slider.live_slider(u_scale, True)\u000av_slider = slider.live_slider(v_scale, True)\u000a\u000acanvas = plot3d_live(data, 100.0, 100.0)\u000aHtml(canvas, '<br>U scale: ', u_slider, 'V scale: ', v_slider)
p210
sg51
I01
sbsbasbsg16
Vplot3d
p211
sg80
I2
sbasb.