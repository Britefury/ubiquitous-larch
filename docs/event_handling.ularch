ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">Event Handling</h1><p>Ubiquitous Larch can receive events in client-side Javascript code and route them to the server-side Python code.</p><p>On the client-side, we call the <code>larch.postEvent</code>&nbsp;Javascript function, passing the source DOM node, the event name&nbsp;and event data (a <a data-cke-saved-href="http://www.json.org/" href="http://www.json.org/">JSON</a> representable&nbsp;value)&nbsp;as parameters. This event will be sent to the server, where it can be handled by your Python code.</p><p>The server maintains its own representation of the structure of the document, allowing it to ensure that the event is routed to the correct handler.</p><p>On the server side, we invoke the <code>with_event_handler</code>&nbsp;Python method, passing the event name and the handler function/callable as parameters.</p><p><br></p><p>In summary,&nbsp;Ubiquitous&nbsp;Larch routes events for you, alleviating the need to explicitly maintain a mapping between&nbsp;pieces of the browser DOM and objects on the server.</p>
p13
sS'notebook'
p14
g4
sbag0
(g8
g2
Ntp15
Rp16
(dp17
g12
V<h2>Example</h2><p>In the following example, we will construct a button that sends an event that is handled server-side.</p>
p18
sg14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockSource
p19
g2
Ntp20
Rp21
(dp22
S'code'
p23
g0
(clarch.apps.source_code
JSCode
p24
g2
Ntp25
Rp26
(dp27
g23
V// The larch.postEvent Javascript function sends an event to the server side Python code. Its parameters are as follows:\u000a// - the DOM node from which the event originates\u000a// - the name of the event to send\u000a// - the event data; an object representable as JSON\u000a\u000afunction on_bt_clicked(node, operation) {\u000a	larch.postEvent(node, "test_button_clicked", operation);\u000a}
p28
sS'editable'
p29
I01
sbsS'var_name'
p30
Vinc_button_js_src
p31
sg14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p32
g2
Ntp33
Rp34
(dp35
g23
g0
(clarch.apps.source_code
PythonCode
p36
g2
Ntp37
Rp38
(dp39
g23
V# We need Html pres type\u000afrom larch.pres.html import Html\u000a\u000a# LiveValue objects simply display their contents, with one difference; if their value is modified, their on-screen representations are automatically refreshed.\u000afrom larch.live import LiveValue\u000a\u000a# Create a live value containing 0\u000ax = LiveValue(0)\u000a\u000a\u000a# The server side response function\u000a# @event_name will be the name of the event sent by the client, in this case 'test_button_clicked'\u000a# @event_data will receive the value of @operation sent from the client side\u000adef on_client_side_button_clicked(event):\u000a    # Increment the value in @x\u000a    x.value += 1\u000a\u000a\u000a# HTML that constructs a button that calls 'on_bt_clicked' when clicked\u000abutton = Html('<button onclick="javascript:on_bt_clicked(this, \u005c'+\u005c');">Increment</button>')\u000a\u000a# Attach the event handler\u000abutton = button.with_event_handler('test_button_clicked', on_client_side_button_clicked)\u000a\u000a# Reference the JS code\u000abutton = button.use_js(source=inc_button_js_src)\u000a\u000a# Arrange the button above the value:\u000aHtml(button, '<div>', x, '</div>')
p40
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp41
Rp42
(dp43
g12
V<p>U-Larch ensures that events are sent to the correct place at the server-side. In the example below, we construct a number of counters, demonstrating the that correct events are sent to the correct handlers, despite sharing the same event name:</p>
p44
sg14
g4
sbag0
(g32
g2
Ntp45
Rp46
(dp47
g23
g0
(g36
g2
Ntp48
Rp49
(dp50
g23
Vdef counter(initial_value=0):\u000a    # Create a live value containing 0\u000a    x = LiveValue(initial_value)\u000a    \u000a    # The server side response function\u000a    def on_client_side_button_clicked(event):\u000a        if event.data == '+':\u000a            x.value += 1\u000a        elif event.data == '-':\u000a            x.value -= 1\u000a        else:\u000a            raise ValueError\u000a    \u000a    \u000a    # Build TWO buttons. They both send an event with the same name. The event data determines what the button should do (+ or -)\u000a    dec_button = Html('<button onclick="javascript:on_bt_clicked(this, \u005c'-\u005c');">Decrement</button>')\u000a    inc_button = Html('<button onclick="javascript:on_bt_clicked(this, \u005c'+\u005c');">Increment</button>')\u000a    \u000a    # Arrange the button above the value:\u000a    ui = Html(dec_button, inc_button, '<div>', x, '</div>')\u000a    \u000a    # Attach the event handler. This time, we are attaching the server-side handler to the whole UI rather than the individual buttons; events bubble up.\u000a    ui = ui.with_event_handler('test_button_clicked', on_client_side_button_clicked)\u000a    \u000a    # Reference the JS code\u000a    ui = ui.use_js(source=inc_button_js_src)\u000a    \u000a    return ui;\u000a    \u000a\u000a# Make 3 counters\u000aHtml(counter(0), counter(1), counter(2))
p51
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp52
Rp53
(dp54
g12
V<p>The counters above are independent from one another, desipite sharing the same code and the same events. U-Larch ensures that the events arrive at the correct place on the server side.</p>
p55
sg14
g4
sbasb.