ccopy_reg
_reconstructor
p0
(clarch.apps.project.project_root
ProjectRoot
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'startup_page_id'
p6
NsS'python_package_name'
p7
V
p8
sS'front_page_id'
p9
NsS'contents'
p10
(lp11
g0
(clarch.apps.project.project_package
ProjectPackage
p12
g2
Ntp13
Rp14
(dp15
S'name'
p16
VLib
p17
sg10
(lp18
sbag0
(g12
g2
Ntp19
Rp20
(dp21
g16
VExamples
p22
sg10
(lp23
g0
(clarch.apps.project.project_page
ProjectPage
p24
g2
Ntp25
Rp26
(dp27
S'data'
p28
g0
(clarch.apps.notebook.notebook
Notebook
p29
g2
Ntp30
Rp31
(dp32
S'blocks'
p33
(lp34
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p35
g2
Ntp36
Rp37
(dp38
S'text'
p39
V<h1>Torus examples</h1><p>First, import the uv mesh stuff:</p>
p40
sS'notebook'
p41
g31
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p42
g2
Ntp43
Rp44
(dp45
S'code'
p46
g0
(clarch.apps.source_code
PythonCode
p47
g2
Ntp48
Rp49
(dp50
g46
Vimport math\u000a\u000afrom larch.live import LiveFunction, LiveValue\u000afrom larch.pres.resource import JsonLiveFnResource\u000afrom larch.controls import slider\u000afrom larch.pres.html import Html\u000a\u000afrom larch.media import webglscene
p51
sS'editable'
p52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp53
Rp54
(dp55
g39
V<h1>Setting up the scene</h1><p>First, we set up a camera and the shader:</p>
p56
sg41
g31
sbag0
(g42
g2
Ntp57
Rp58
(dp59
g46
g0
(g47
g2
Ntp60
Rp61
(dp62
g46
Vcam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 12.0, 0.0, math.radians(30.0))\u000amaterial = webglscene.Material.plain_white\u000a
p63
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp64
Rp65
(dp66
g39
V<h1>Building a torus</h1><p>We need to build a torus in two ways; as a mesh, and as a UV mesh where the structure of the model is implicit. Mesh first (generate both vertices and indices):</p>
p67
sg41
g31
sbag0
(g42
g2
Ntp68
Rp69
(dp70
g46
g0
(g47
g2
Ntp71
Rp72
(dp73
g46
Vdef mesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y\u000a            nx = minor_x * major_x \u000a            nz = minor_x * major_z\u000a            ny = minor_y\u000a            \u000a            vertices.extend([x, y, z, nx, ny, nz])\u000a            #vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a    \u000a    indices = []\u000a    for p, q in zip(range(major_segs), range(1, major_segs)+[0]):\u000a        for i, j in zip(range(minor_segs), range(1, minor_segs)+[0]):\u000a            a = i + p * minor_segs\u000a            b = j + p * minor_segs\u000a            c = i + q * minor_segs\u000a            d = j + q * minor_segs\u000a            indices.extend([a, b, c, c, b, d])\u000a            \u000a    return vertices, indices
p74
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp75
Rp76
(dp77
g39
V<p>Now for the UV mesh:</p>
p78
sg41
g31
sbag0
(g42
g2
Ntp79
Rp80
(dp81
g46
g0
(g47
g2
Ntp82
Rp83
(dp84
g46
Vdef uvmesh_torus(major_radius, major_segs, minor_radius, minor_segs):\u000a    vertices = []\u000a    delta_theta = math.pi * 2 / major_segs\u000a    delta_phi = math.pi * 2 / minor_segs\u000a    theta = 0.0\u000a    for i in xrange(major_segs):\u000a        phi = 0.0\u000a        major_x = math.cos(theta)\u000a        major_z = math.sin(theta)\u000a        for j in xrange(minor_segs):\u000a            minor_x = -math.cos(phi)\u000a            minor_y = math.sin(phi)\u000a            \u000a            x = (minor_x * minor_radius  +  major_radius) * major_x \u000a            z = (minor_x * minor_radius  +  major_radius) * major_z\u000a            y = minor_y * minor_radius\u000a            \u000a            vertices.extend([x, y, z])\u000a            \u000a            phi += delta_phi\u000a            \u000a        theta += delta_theta\u000a            \u000a    return vertices
p85
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp86
Rp87
(dp88
g39
V<h1>Example: mesh torus</h1>
p89
sg41
g31
sbag0
(g42
g2
Ntp90
Rp91
(dp92
g46
g0
(g47
g2
Ntp93
Rp94
(dp95
g46
Vmesh_verts, mesh_indices = mesh_torus(4.0, 32, 1.0, 16)\u000atorus_mesh = webglscene.MeshEntity(material, [['vertexPos', 3], ['vertexNrm', 3]], mesh_verts, [['triangles', mesh_indices]])\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [torus_mesh]))
p96
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp97
Rp98
(dp99
g39
V<p>Example: UV mesh torus</p>
p100
sg41
g31
sbag0
(g42
g2
Ntp101
Rp102
(dp103
g46
g0
(g47
g2
Ntp104
Rp105
(dp106
g46
Vuvmesh_vertpos = uvmesh_torus(4.0, 32, 1.0, 16)\u000a\u000auvsource = webglscene.UVMeshDataLiteral(16, 32, True, True, uvmesh_vertpos, [])\u000auvtorus = webglscene.UVMeshEntity(material, uvsource)\u000a\u000awebglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvtorus]))
p107
sg52
I01
sbsg41
g31
sbag0
(g35
g2
Ntp108
Rp109
(dp110
g39
V<h1>Example: UV mesh torus as resource</h1>
p111
sg41
g31
sbag0
(g42
g2
Ntp112
Rp113
(dp114
g46
g0
(g47
g2
Ntp115
Rp116
(dp117
g46
Vmaj_rad = LiveValue(40)\u000amin_rad = LiveValue(10) \u000amaj_segs = LiveValue(32)\u000amin_segs = LiveValue(16) \u000a\u000a\u000a@JsonLiveFnResource\u000a@LiveFunction\u000adef torus_rsc():\u000a    vertices = uvmesh_torus(float(maj_rad.value)*0.1, maj_segs.value, float(min_rad.value)*0.1, min_segs.value)\u000a    return {\u000a            'uSegs': min_segs.value,\u000a            'vSegs': maj_segs.value,\u000a            'closedU': True,\u000a            'closedV': True,\u000a            'vertexPositions': vertices,\u000a            'vertexAttribsNamesSizesData': []\u000a            }\u000a\u000a\u000amaj_rad_slider = slider.live_slider(maj_rad, True)\u000amin_rad_slider = slider.live_slider(min_rad, True)\u000a\u000amaj_segs_slider = slider.live_slider(maj_segs, True)\u000amin_segs_slider = slider.live_slider(min_segs, True)\u000a\u000auvrsc = webglscene.UVMeshDataResource(torus_rsc)\u000auvrsctorus = webglscene.UVMeshEntity(material, uvrsc)\u000a\u000acanvas = webglscene.scene_canvas(800, 600, webglscene.Scene(cam, [uvrsctorus]))\u000aHtml(canvas, '<br>Major radius: ', maj_rad_slider, 'Major segments: ', maj_segs_slider, 'Minor radius: ', min_rad_slider, 'Minor segments: ', min_segs_slider)
p118
sg52
I01
sbsg41
g31
sbasbsg16
VTorusExamples
p119
sS'id'
p120
I1
sbasbag0
(g24
g2
Ntp121
Rp122
(dp123
g28
g0
(g29
g2
Ntp124
Rp125
(dp126
g33
(lp127
g0
(g35
g2
Ntp128
Rp129
(dp130
g39
V<h1>3D Plotting</h1><p>Imports first:</p>
p131
sg41
g125
sbag0
(g42
g2
Ntp132
Rp133
(dp134
g46
g0
(g47
g2
Ntp135
Rp136
(dp137
g46
Vimport math\u000a\u000afrom larch.live import LiveFunction, LiveValue\u000afrom larch.pres.resource import JsonLiveFnResource\u000afrom larch.controls import slider\u000afrom larch.pres.html import Html\u000a\u000afrom larch.media import webglscene
p138
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp139
Rp140
(dp141
g39
V<p>Now define 3D plotting function:</p>
p142
sg41
g125
sbag0
(g42
g2
Ntp143
Rp144
(dp145
g46
g0
(g47
g2
Ntp146
Rp147
(dp148
g46
Vdef plot3d_entity(data, width, depth, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a    \u000a    return uvmesh\u000a
p149
sg52
I01
sbsg41
g125
sbag0
(g42
g2
Ntp150
Rp151
(dp152
g46
g0
(g47
g2
Ntp153
Rp154
(dp155
g46
Vdef plot3d(data, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    uvmesh = plot3d_entity(data, width, depth, material=material)\u000a    \u000a    v_segs = len(data)\u000a    u_segs = len(data[0])\u000a    \u000a    vertex_positions = []\u000a    vertex_tex = None\u000a    vertex_attribs_names_sizes_data = []\u000a    \u000a    if generate_tex_coords:\u000a        vertex_tex = []\u000a        vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a    \u000a    delta_z = depth / v_segs\u000a    delta_x = width / u_segs\u000a    delta_s = 1.0 / u_segs\u000a    delta_t = 1.0 / v_segs\u000a\u000a    min_y = 1.0e18\u000a    max_y = -1.0e18\u000a    z = depth * -0.5\u000a    t = 0.0\u000a    for row in data:\u000a        x = width * -0.5\u000a        s = 0.0\u000a        for col in row:\u000a            vertex_positions.extend([x, col, z])\u000a            if generate_tex_coords:\u000a                vertex_tex.extend([s, t])\u000a            min_y = min(min_y, col)\u000a            max_y = max(max_y, col)\u000a            x += delta_x\u000a            s += delta_s\u000a        z += delta_z\u000a        t += delta_t\u000a        \u000a    focal_y = (min_y + max_y) * 0.5\u000a    \u000a    dim = max(width, depth, max_y - min_y)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, focal_y, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataLiteral(u_segs, v_segs, False, False, vertex_positions, vertex_attribs_names_sizes_data)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a\u000a
p156
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp157
Rp158
(dp159
g39
V<p>Live plotting:</p>
p160
sg41
g125
sbag0
(g42
g2
Ntp161
Rp162
(dp163
g46
g0
(g47
g2
Ntp164
Rp165
(dp166
g46
Vdef plot3d_live(data_live, width, depth, canvas_width=800, canvas_height=600, material=webglscene.Material.plain_white, generate_tex_coords=False):\u000a    @JsonLiveFnResource\u000a    @LiveFunction\u000a    def plot_rsc():\u000a        data = data_live.value\u000a        \u000a        v_segs = len(data)\u000a        u_segs = len(data[0])\u000a        \u000a        vertex_positions = []\u000a        vertex_attribs_names_sizes_data = []\u000a        if generate_tex_coords:\u000a            vertex_tex = []\u000a            vertex_attribs_names_sizes_data.append(['vertexTex', 2, vertex_tex])\u000a        \u000a        \u000a        delta_z = depth / v_segs\u000a        delta_x = width / u_segs\u000a        delta_s = 1.0 / u_segs\u000a        delta_t = 1.0 / v_segs\u000a    \u000a        z = depth * -0.5\u000a        t = 0.0\u000a        for row in data:\u000a            x = width * -0.5\u000a            s = 0.0\u000a            for col in row:\u000a                vertex_positions.extend([x, col, z])\u000a                if generate_tex_coords:\u000a                    vertex_tex.extend([s, t])\u000a                x += delta_x\u000a                s += delta_s\u000a            z += delta_z\u000a            t += delta_t\u000a\u000a        return {\u000a                'uSegs': u_segs,\u000a                'vSegs': v_segs,\u000a                'closedU': False,\u000a                'closedV': False,\u000a                'vertexPositions': vertex_positions,\u000a                'vertexAttribsNamesSizesData': vertex_attribs_names_sizes_data\u000a                }\u000a    \u000a    dim = max(width, depth)\u000a    \u000a    cam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], dim * 1.5, 0.0, math.radians(30.0))\u000a\u000a    uvsource = webglscene.UVMeshDataResource(plot_rsc)\u000a    uvmesh = webglscene.UVMeshEntity(material, uvsource)\u000a\u000a    return webglscene.scene_canvas(canvas_width, canvas_height, webglscene.Scene(cam, [uvmesh]))\u000a
p167
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp168
Rp169
(dp170
g39
V<p>Test (literal first):</p>
p171
sg41
g125
sbag0
(g42
g2
Ntp172
Rp173
(dp174
g46
g0
(g47
g2
Ntp175
Rp176
(dp177
g46
Vplot3d([[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)], 100.0, 100.0)
p178
sg52
I01
sbsg41
g125
sbag0
(g35
g2
Ntp179
Rp180
(dp181
g39
V<p>Now live data:</p>
p182
sg41
g125
sbag0
(g42
g2
Ntp183
Rp184
(dp185
g46
g0
(g47
g2
Ntp186
Rp187
(dp188
g46
Vu_scale = LiveValue(10)\u000av_scale = LiveValue(10) \u000a\u000a\u000a@LiveFunction\u000adef data():\u000a    us = u_scale.value*0.01\u000a    vs = v_scale.value*0.01\u000a    return [[float(((i-8)**2)*us+((j-8)**2))*vs   for i in xrange(16)] for j in xrange(16)]\u000a    #return [[float((i-8)**2+(j-8)**2)   for i in xrange(16)] for j in xrange(16)]\u000a\u000au_slider = slider.live_slider(u_scale, True)\u000av_slider = slider.live_slider(v_scale, True)\u000a\u000acanvas = plot3d_live(data, 100.0, 100.0)\u000aHtml(canvas, '<br>U scale: ', u_slider, 'V scale: ', v_slider)
p189
sg52
I01
sbsg41
g125
sbasbsg16
Vplot3d
p190
sg120
I2
sbag0
(g24
g2
Ntp191
Rp192
(dp193
g28
g0
(g29
g2
Ntp194
Rp195
(dp196
g33
(lp197
g0
(g35
g2
Ntp198
Rp199
(dp200
g39
V<h1 style="text-align: center;">Using NumPy and SciPy to generate Philips Spectrum based ocean waves</h1>
p201
sg41
g195
sbag0
(g42
g2
Ntp202
Rp203
(dp204
g46
g0
(g47
g2
Ntp205
Rp206
(dp207
g46
Vimport math\u000aimport numpy as np\u000aimport random\u000a#from matplotlib import *\u000a\u000aimport plot3d\u000a\u000a\u000a\u000a\u000aclass PhilipsSpectrum (object):\u000a    def __init__(self, wave_height_factor, wind_speed, wind_vector, gravitational_constant, smoothness):\u000a        wind_inv_len = 1.0/math.sqrt(wind_vector[0]*wind_vector[0] + wind_vector[1]*wind_vector[1])\u000a        wind_vector[0] *= wind_inv_len\u000a        wind_vector[1] *= wind_inv_len\u000a        \u000a        self.wave_height_factor = wave_height_factor\u000a        self.wind_speed = wind_speed\u000a        self.wind_vector = wind_vector\u000a        self.largest_wave = wind_speed * wind_speed / gravitational_constant\u000a        self.gravitational_constant = gravitational_constant\u000a        self.smoothness = smoothness\u000a\u000a        \u000a\u000a    def philips_spectrum(self, kx, ky):\u000a        k_length = math.sqrt(kx*kx + ky*ky)\u000a        j = k_length / (2.0 * math.pi)\u000a        j2 = j * j\u000a        j4 = j2 * j2\u000a    \u000a        a = self.wave_height_factor\u000a        jl = j * self.largest_wave\u000a        e_ = -1.0 / (jl * jl)\u000a        b = math.exp(e_) / j4\u000a        knx = kx / k_length\u000a        kny = ky / k_length\u000a        k_dot_w = knx * self.wind_vector[0]  +  kny * self.wind_vector[1]\u000a        c = k_dot_w * k_dot_w\u000a        l = self.largest_wave * self.smoothness\u000a        d = math.exp(-j2 * l*l)\u000a\u000a        return a * b * c * d\u000a\u000a    \u000a    \u000a    def philips_matrix(self, size, resolution):\u000a        n_verts = resolution + 1\u000a        \u000a        k = np.linspace(0.0, 2.0 * math.pi * resolution / size, n_verts)\u000a        \u000a        inv_sqrt_2 = 1.0 / math.sqrt(2.0)\u000a        \u000a        philips = np.zeros((n_verts, n_verts))\u000a        \u000a        for y in xrange(n_verts):\u000a            for x in xrange(n_verts):\u000a                if x != 0  or  y != 0:\u000a                    p = self.philips_spectrum(k[x], k[y])\u000a                else:\u000a                    p = 0.0\u000a                q = inv_sqrt_2 * math.sqrt(p)\u000a                \u000a                philips[y,x] = q\u000a        \u000a        return philips\u000a    \u000a    \u000a    \u000a    \u000aclass Ocean (object):\u000a    def __init__(self, rnd_state, size, resolution, time_step):\u000a        \u000a        self.gravitational_constant = 1.0\u000a        self.size = size\u000a        self.resolution = resolution\u000a        self.n_verts = resolution + 1\u000a        self.time_step = time_step\u000a        \u000a        self.freq_rnd = rnd_state.randn(self.n_verts, self.n_verts) + rnd_state.randn(self.n_verts, self.n_verts) * 1j\u000a        self.freq = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.heights = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        \u000a        self.single_step = np.zeros((self.n_verts, self.n_verts), dtype=complex)\u000a        self.step_table = []\u000a        \u000a        self.vertex_positions = []\u000a        \u000a        self.__update_step_table()\u000a        \u000a        \u000a    \u000a    def __update_step_table(self):\u000a        for y in xrange(self.n_verts):\u000a            for x in xrange(self.n_verts):\u000a                ux = x / self.size\u000a                uy = y / self.size\u000a                u = math.sqrt(ux*ux +uy*uy)\u000a                omega = math.sqrt(u * self.gravitational_constant) * self.time_step\u000a                c = math.cos(omega)\u000a                s = math.sin(omega)\u000a                self.single_step[y,x] = c + s *  1j\u000a                self.step_table = [self.single_step]\u000a        \u000a    \u000a    def apply_philips(self, spectrum):\u000a        philips = spectrum.philips_matrix(self.size, self.resolution)\u000a        \u000a        g_changed = self.gravitational_constant != spectrum.gravitational_constant\u000a        if g_changed:\u000a            self.gravitational_constant = spectrum.gravitational_constant\u000a            self.__update_step_table()\u000a        \u000a        \u000a        self.freq = self.freq_rnd * philips\u000a        \u000a                \u000a                \u000a                \u000a    def step(self, delta_t):\u000a        steps = int(delta_t / self.time_step)\u000a        if steps != 0:\u000a            ndx = steps - 1\u000a            try:\u000a                u = self.step_table[ndx]\u000a            except IndexError:\u000a                u = self.step_table[-1]\u000a                for i in xrange(len(self.step_table),ndx):\u000a                    u = u * self.single_step\u000a                    self.step_table.append(u)\u000a            \u000a            self.freq = self.freq * u\u000a        \u000a        \u000a    def update_heights(self):\u000a        spatial = np.fft.fft2(self.freq)\u000a        self.heights = np.array(spatial, dtype=float)\u000a        \u000a        self.vertex_positions = []\u000a        dx = self.size / self.resolution\u000a        z = 0.0\u000a        for j in xrange(self.n_verts):\u000a            x = 0.0\u000a            for i in xrange(self.n_verts):\u000a                self.vertex_positions.extend([x,self.heights[j,i],z])\u000a                x += dx\u000a            z += dx\u000a                \u000a                \u000a    \u000a    \u000a\u000a#o = Ocean(random.Random(123), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000a#o = Ocean(random.Random(223783), 100.0, 127, 0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2, 0.005)\u000aphilips_spectrum = PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000ao = Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000ao.apply_philips(philips_spectrum)\u000a\u000ao.step(0.5)\u000ao.update_heights()\u000a#imshow(o.heights)\u000a\u000aplot3d.plot3d(o.heights, o.size, o.size)
p208
sg52
I01
sbsg41
g195
sbasbsg16
Vocean
p209
sg120
I3
sbag0
(g24
g2
Ntp210
Rp211
(dp212
g28
g0
(g29
g2
Ntp213
Rp214
(dp215
g33
(lp216
g0
(g35
g2
Ntp217
Rp218
(dp219
g39
V<h1 style="text-align: center;">Using NumPy to generate a fractal landscape</h1>
p220
sg41
g214
sbag0
(g42
g2
Ntp221
Rp222
(dp223
g46
g0
(g47
g2
Ntp224
Rp225
(dp226
g46
Vimport numpy as np\u000afrom scipy import interpolate\u000afrom larch.media import webglscene\u000afrom larch.pres.resource import ImageFromFile\u000aimport plot3d\u000a\u000a\u000a\u000adef make_harmonic(rnd, resolution, magnitude):\u000a    return rnd.randn(resolution+1, resolution+1) * magnitude\u000a\u000a\u000adef upscale_harmonic(h, resolution):\u000a    x = np.linspace(0.0, 1.0, len(h))\u000a    p = interpolate.interp2d(x, x, h, kind='cubic')\u000a    x_new = np.linspace(0.0, 1.0, resolution+1)\u000a    return p(x_new, x_new)\u000a    \u000a\u000a    \u000adef fractal_heightfield(rand_state, resolution, size, n_harmonics, top_h_res, magnitude, mag_scale):\u000a    # Generate harmonics\u000a    harmonics = []\u000a    h_res = top_h_res\u000a    h_mag = magnitude * mag_scale**(n_harmonics-1)\u000a    for i in xrange(n_harmonics):\u000a        h = make_harmonic(rand_state, h_res, h_mag)\u000a        h = upscale_harmonic(h, resolution)\u000a        harmonics.append(h)\u000a        h_res /= 2\u000a        h_mag = h_mag / mag_scale\u000a    \u000a    return sum(harmonics)\u000a    \u000a\u000a\u000ah = fractal_heightfield(np.random.RandomState(123), 128, 100.0, 4, 32, 5.0, 0.3)\u000amaterial=webglscene.Material.single_texture_2d(ImageFromFile('testimages/Sand.jpg'))\u000aplot3d.plot3d(h, len(h), len(h[0]), material=material, generate_tex_coords=True)
p227
sg52
I01
sbsg41
g214
sbasbsg16
Vfractal_landscape
p228
sg120
I4
sbag0
(g24
g2
Ntp229
Rp230
(dp231
g28
g0
(g29
g2
Ntp232
Rp233
(dp234
g33
(lp235
g0
(g35
g2
Ntp236
Rp237
(dp238
g39
V<h1 style="text-align:center">WebGL based 3D tropical ocean</h1><p><br></p><p>Please execute the code (<code>Ctrl-Enter</code> or click the button at the top of the page) and scroll to the bottom of the page to see a cool demo, showing a tropical ocean.</p><p><br></p><p>This demo is split up into a number of modules. They are contained in an overall <a data-cke-saved-href="/pages/docs/webglscene_example" href="/pages/docs/webglscene_example">project</a>.</p><p><br></p><p>Please note that this demo uses a home-grown WebGL based 3D graphics library. It is likely to be deprecated in favour of something else in the future, to please don't start using it for anything (even if you do manage to figure out how to use the undocumented API!)</p>
p239
sg41
g233
sbag0
(g35
g2
Ntp240
Rp241
(dp242
g39
V<h2>Shaders</h2><p>This example makes use of a number of GLSL shaders.</p><p>First, we have the surface shaders which compute the light contribution of the surface of the object that we are rendering.</p><p>Next, we have the volume shaders which create a volumetric fog effect underwater.</p><p>Finally, we have a shader that puts the two components together.</p>
p243
sg41
g233
sbag0
(g35
g2
Ntp244
Rp245
(dp246
g39
V<h3>Surface shaders</h3><p>Ocean: plain</p>
p247
sg41
g233
sbag0
(clarch.apps.notebook.notebook
NotebookBlockSource
p248
g2
Ntp249
Rp250
(dp251
g46
g0
(clarch.apps.source_code
GLSLCode
p252
g2
Ntp253
Rp254
(dp255
g46
Vvoid surface(void) {\u000a	colour = vec3(dot(vertexNrm, vec3(0,1,0))) * vec3(0.0, 0.5, 1.0);\u000a}
p256
sg52
I01
sbsS'var_name'
p257
Vocean_plain_vert
p258
sg41
g233
sbag0
(g248
g2
Ntp259
Rp260
(dp261
g46
g0
(g252
g2
Ntp262
Rp263
(dp264
g46
Vvec4 surface(void) {\u000a	return vec4(colour, 1.0)*0.5+0.5;\u000a}
p265
sg52
I01
sbsg257
Vocean_plain_frag
p266
sg41
g233
sbag0
(g35
g2
Ntp267
Rp268
(dp269
g39
V<p>Ocean: fresnel</p>
p270
sg41
g233
sbag0
(g248
g2
Ntp271
Rp272
(dp273
g46
g0
(g252
g2
Ntp274
Rp275
(dp276
g46
Vconst float f0 = 0.05;\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avoid surface(void)\u000a{\u000a	vec3 worldSpaceEye = normalize( camPos.xyz - vertexPos.xyz );\u000a	\u000a	vec3 normal = dot( vertexNrm, worldSpaceEye )  >  0.0  ?  vertexNrm  :  -vertexNrm;\u000a	\u000a	float cosTheta = dot( worldSpaceEye, normal );\u000a	float omCosTheta = 1.0 - cosTheta;\u000a	float omCosTheta2 = omCosTheta * omCosTheta;\u000a	float omCosTheta4 = omCosTheta2 * omCosTheta2;\u000a	float omCosTheta5 = omCosTheta4 * omCosTheta;\u000a	frag_surf_water_f = f0  +  omCosTheta5 * ( 1.0 - f0 );\u000a	\u000a	float nDotE = dot( normal, worldSpaceEye );\u000a	vec3 projN = normal * nDotE;\u000a	frag_surf_water_refl = projN - ( worldSpaceEye - projN );\u000a}\u000a
p277
sg52
I01
sbsg257
Vocean_fresnel_vert
p278
sg41
g233
sbag0
(g248
g2
Ntp279
Rp280
(dp281
g46
g0
(g252
g2
Ntp282
Rp283
(dp284
g46
Vconst vec3 refrCol = vec3( vec3( 0.090, 0.341, 0.482 )*0.75 );\u000a\u000a\u000avarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	vec3 col = mix(refrCol, reflCol, frag_surf_water_f);\u000a\u000a	return vec4( col, 1.0 );\u000a}\u000a
p285
sg52
I01
sbsg257
Vocean_fresnel_frag
p286
sg41
g233
sbag0
(g248
g2
Ntp287
Rp288
(dp289
g46
g0
(g252
g2
Ntp290
Rp291
(dp292
g46
Vvarying vec3 frag_surf_water_refl;\u000avarying float frag_surf_water_f;\u000a\u000a\u000avec4 surface(void)\u000a{\u000a	vec3 reflCol = textureCube( sky, frag_surf_water_refl ).rgb;\u000a\u000a	return vec4( reflCol * frag_surf_water_f, 1.0 - frag_surf_water_f );\u000a}\u000a
p293
sg52
I01
sbsg257
Vocean_transparent_fresnel_frag
p294
sg41
g233
sbag0
(g35
g2
Ntp295
Rp296
(dp297
g39
V<p>Terrain</p>
p298
sg41
g233
sbag0
(g248
g2
Ntp299
Rp300
(dp301
g46
g0
(g252
g2
Ntp302
Rp303
(dp304
g46
Vattribute vec2 vertexTex;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avoid surface(void) {\u000a	lighting = vec3(dot(vertexNrm, vec3(0,1,0)))*0.5+0.5;\u000a	texCoord = vertexTex;\u000a}
p305
sg52
I01
sbsg257
Vterrain_vert
p306
sg41
g233
sbag0
(g248
g2
Ntp307
Rp308
(dp309
g46
g0
(g252
g2
Ntp310
Rp311
(dp312
g46
Vuniform sampler2D sampler;\u000a\u000avarying vec3 lighting;\u000avarying vec2 texCoord;\u000a\u000avec4 surface(void) {\u000a	return texture2D(sampler, texCoord) * vec4(lighting, 1.0);\u000a}\u000a
p313
sg52
I01
sbsg257
Vterrain_frag
p314
sg41
g233
sbag0
(g35
g2
Ntp315
Rp316
(dp317
g39
V<h3>Volume shaders</h3><p>Identity</p>
p318
sg41
g233
sbag0
(g248
g2
Ntp319
Rp320
(dp321
g46
g0
(g252
g2
Ntp322
Rp323
(dp324
g46
Vvoid volume(void)\u000a{\u000a}\u000a
p325
sg52
I01
sbsg257
Vvol_identity_vert
p326
sg41
g233
sbag0
(g248
g2
Ntp327
Rp328
(dp329
g46
g0
(g252
g2
Ntp330
Rp331
(dp332
g46
Vvec4 volume(vec4 surface)\u000a{\u000a	return surface;\u000a}\u000a
p333
sg52
I01
sbsg257
Vvol_identity_frag
p334
sg41
g233
sbag0
(g35
g2
Ntp335
Rp336
(dp337
g39
V<p>Oceanic fog</p>
p338
sg41
g233
sbag0
(g248
g2
Ntp339
Rp340
(dp341
g46
g0
(g252
g2
Ntp342
Rp343
(dp344
g46
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 1.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y > 0.0  &&  vertexPos.y > 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( camPos.y <= 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else if ( camPos.y > 0.0  &&  vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera above water, vertex below water\u000a			y1 = -vertexPos.y;\u000a			float fracBelowWater = y1 / ( camPos.y + y1 );\u000a			distance *= fracBelowWater;\u000a			y0 = 0.0;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p345
sg52
I01
sbsg257
Vvol_oceanfog_vert
p346
sg41
g233
sbag0
(g248
g2
Ntp347
Rp348
(dp349
g46
g0
(g252
g2
Ntp350
Rp351
(dp352
g46
V//const float fogK = -log( 0.94 );\u000afloat fogK = -log( 0.97 );\u000a\u000avec3 fogLightExtinction = vec3( 32.0/255.0, 127.0/255.0, 181.0/255.0 );\u000afloat fogLightExtinctionDist = 2.5;\u000avec3 fogM = -log( pow( fogLightExtinction, vec3(1,1,1)*(1.0/fogLightExtinctionDist) ) );\u000avec3 fogLightColour = vec3( 214.0/255.0, 239.0/255.0, 255.0/255.0 );\u000a\u000a\u000avarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000avoid volume(void)\u000a{\u000a	float y0, y1;\u000a	\u000a	if ( camPos.y >= 0.0 )\u000a	{\u000a		// Camera and vertex above water - no fog\u000a		frag_vol_oceanFog_volume = vec3( 0.0, 0.0, 0.0 );\u000a		frag_vol_oceanFog_transparency = vec4( 1.0, 1.0, 1.0, 1.0 );\u000a	}\u000a	else\u000a	{\u000a		vec3 camToVert = vertexPos.xyz - camPos.xyz;\u000a		float distance = sqrt( dot( camToVert, camToVert ) );\u000a		\u000a		if ( vertexPos.y <= 0.0 )\u000a		{\u000a			// Camera and vertex below water\u000a			y0 = -camPos.y;\u000a			y1 = -vertexPos.y;\u000a		}\u000a		else\u000a		{\u000a			// Camera below water, vertex above water\u000a			y0 = -camPos.y;\u000a			float fracBelowWater = y0 / ( vertexPos.y + y0 );\u000a			distance *= fracBelowWater;\u000a			y1 = 0.0;\u000a		}\u000a		float z = ( y1 - y0 ) / distance;\u000a		\u000a		\u000a		vec3 a = -( fogK + fogM * z );\u000a		vec3 b = exp( -fogM * y0 );\u000a		vec3 c = exp( a * distance );\u000a		vec3 fogColour = (b/a) * (c-1.0) * fogK;\u000a		frag_vol_oceanFog_volume = fogColour * fogLightColour;\u000a\u000a		float fogTrans = exp( -fogK * distance );\u000a		frag_vol_oceanFog_transparency = vec4( exp( -fogM * y1 ) * fogTrans, fogTrans );\u000a	}\u000a}\u000a
p353
sg52
I01
sbsg257
Vvol_oceanfog_forocean_vert
p354
sg41
g233
sbag0
(g248
g2
Ntp355
Rp356
(dp357
g46
g0
(g252
g2
Ntp358
Rp359
(dp360
g46
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, 1.0 );\u000a}
p361
sg52
I01
sbsg257
Vvol_oceanfog_frag
p362
sg41
g233
sbag0
(g248
g2
Ntp363
Rp364
(dp365
g46
g0
(g252
g2
Ntp366
Rp367
(dp368
g46
Vvarying vec4 frag_vol_oceanFog_transparency;\u000avarying vec3 frag_vol_oceanFog_volume;\u000a\u000a\u000a\u000avec4 volume(vec4 surface)\u000a{\u000a	float transparency = frag_vol_oceanFog_transparency.a;\u000a	float alpha = surface.a * transparency;\u000a	return vec4( surface.rgb * frag_vol_oceanFog_transparency.rgb  +  frag_vol_oceanFog_volume, alpha );\u000a}\u000a
p369
sg52
I01
sbsg257
Vvol_oceanfog_transparent_frag
p370
sg41
g233
sbag0
(g35
g2
Ntp371
Rp372
(dp373
g39
V<h3>Overall shader</h3>
p374
sg41
g233
sbag0
(g248
g2
Ntp375
Rp376
(dp377
g46
g0
(g252
g2
Ntp378
Rp379
(dp380
g46
Vprecision highp float;\u000a\u000auniform mat4 cameraMatrix;\u000auniform mat4 projectionMatrix;\u000auniform vec4 camPos;\u000a\u000aattribute vec3 vertexPos;\u000aattribute vec3 vertexNrm;\u000a\u000avarying vec3 colour;\u000a\u000avoid surface(void);\u000avoid volume(void);\u000a\u000a\u000avoid main(void)\u000a{\u000a	gl_Position = projectionMatrix * cameraMatrix * vec4(vertexPos, 1.0);\u000a	\u000a	surface();\u000a	volume();\u000a}\u000a
p381
sg52
I01
sbsg257
Vmain_vert
p382
sg41
g233
sbag0
(g248
g2
Ntp383
Rp384
(dp385
g46
g0
(g252
g2
Ntp386
Rp387
(dp388
g46
Vprecision highp float;\u000a\u000auniform samplerCube sky;\u000a\u000avarying vec3 colour;\u000a\u000avec4 surface(void);\u000avec4 volume(vec4);\u000a\u000a\u000avoid main(void)\u000a{\u000a	vec4 surf = surface();\u000a	vec4 vol = volume( surf );\u000a	gl_FragColor = vol;\u000a}\u000a
p389
sg52
I01
sbsg257
Vmain_frag
p390
sg41
g233
sbag0
(g35
g2
Ntp391
Rp392
(dp393
g39
V<h2>Display the scene</h2><p>Now, we build the scene from its various parts and display it together.</p><p>We use a fractal landscape, generated in the <a data-cke-saved-href="/pages/docs/webglscene_example/fractal_landscape" href="/pages/docs/webglscene_example/fractal_landscape">fractal_landscape</a>&nbsp;module.</p><p>We use a Philips Spectrum based ocean wave, generated on the <a data-cke-saved-href="/pages/docs/webglscene_example/ocean" href="/pages/docs/webglscene_example/ocean">ocean</a> module.</p><p>We mix these with a skybox and a turn-table camera.</p>
p394
sg41
g233
sbag0
(g42
g2
Ntp395
Rp396
(dp397
g46
g0
(g47
g2
Ntp398
Rp399
(dp400
g46
Vimport math\u000a\u000aimport numpy as np\u000a\u000afrom larch.media import webglscene\u000afrom larch.pres.resource import ImageFromFile\u000a\u000a\u000aimport fractal_landscape\u000aimport ocean\u000aimport plot3d\u000a\u000a\u000a# Ocean function\u000adef make_ocean():\u000a    philips_spectrum = ocean.PhilipsSpectrum(0.0000010, 10.0, [1.0, 0.5], 9.81, 0.2)\u000a    o = ocean.Ocean(np.random.RandomState(223783), 100.0, 127, 0.005)\u000a    o.apply_philips(philips_spectrum)\u000a    \u000a    o.step(0.5)\u000a    o.update_heights()\u000a    \u000a    return o\u000a\u000a\u000a\u000a#\u000a# Sky textures\u000a#\u000a\u000asky_names = [\u000a             'testimages/skybox_east',\u000a             'testimages/skybox_west',\u000a             'testimages/skybox_down',\u000a             'testimages/skybox_up',\u000a             'testimages/skybox_south',\u000a             'testimages/skybox_north'\u000a             ]\u000a\u000asky_textures = [ImageFromFile('{0}.jpg'.format(n))   for n in sky_names]\u000a\u000a\u000a# Sky\u000asky = webglscene.Skybox(sky_textures)\u000a\u000a# Sky cubemap\u000asky_cube = webglscene.TextureCube(sky_textures)\u000a\u000a# Camera\u000acam = webglscene.TurntableCamera(45.0, 0.01, 100.0, [0.0, 0.0, 0.0], 150.0, 0.0, math.radians(30.0))\u000a\u000a\u000a\u000a#\u000a# Landscape material\u000a#\u000alandscape_material_plain = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_identity_vert], [main_frag + terrain_frag + vol_identity_frag]),\u000a    {'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000alandscape_material_oceanfog = webglscene.Material(webglscene.Shader([main_vert + terrain_vert + vol_oceanfog_vert], [main_frag + terrain_frag + vol_oceanfog_frag]),\u000a    {'sampler': webglscene.Texture2D(ImageFromFile('testimages/Sand.jpg'))})\u000a\u000a\u000alandscape_material = landscape_material_oceanfog\u000a\u000a\u000a# Landscape\u000alandscape_heightfield = fractal_landscape.fractal_heightfield(np.random.RandomState(2), 128, 100.0, 4, 32, 5.0, 0.3)\u000alandscape = plot3d.plot3d_entity(landscape_heightfield, 100.0, 100.0, material=landscape_material, generate_tex_coords=True)\u000a\u000a\u000a\u000a#\u000a# Ocean material\u000a#\u000a\u000aocean_material_plain = webglscene.Material(webglscene.Shader([main_vert + ocean_plain_vert + vol_identity_vert], [main_frag + ocean_plain_frag + vol_identity_frag]))\u000aocean_material_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_fresnel_frag + vol_identity_frag]),\u000a        {'sky': sky_cube})\u000aocean_material_trans_fresnel = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_identity_vert], [main_frag + ocean_transparent_fresnel_frag + vol_identity_frag]),\u000a        {'sky': sky_cube}, use_blending=True)\u000aocean_material_trans_fresnel_oceanfog = webglscene.Material(webglscene.Shader([main_vert + ocean_fresnel_vert + vol_oceanfog_forocean_vert], [main_frag + ocean_transparent_fresnel_frag + vol_oceanfog_transparent_frag]),\u000a        {'sky': sky_cube}, use_blending=True)\u000a\u000aocean_material = ocean_material_trans_fresnel_oceanfog\u000a\u000a\u000a# Ocean\u000aoc = make_ocean()\u000aoc3d = plot3d.plot3d_entity(oc.heights, oc.size, oc.size, material=ocean_material)\u000a\u000a\u000a# Scene on canvas\u000awebglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape, oc3d]))\u000a#webglscene.scene_canvas(1280, 800, webglscene.Scene(cam, [sky, landscape]))\u000a
p401
sg52
I01
sbsg41
g233
sbag0
(g35
g2
Ntp402
Rp403
(dp404
g39
V<h2>Controls</h2><p><strong>Alt + left-button-drag</strong>: rotate around the scene</p><p><strong>Alt + right-button-drag</strong>: zoom in and out</p><p><strong>Please note</strong>: the scene will appear black at first. Use the above controls to move the camera around and the scene should appear properly after the textures have loaded.</p>
p405
sg41
g233
sbasbsg16
VCool_Demo
p406
sg120
I5
sbasb.