ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">Client side and server side all in one</h1><p><br></p><p>A notebook can function a bit like a <a data-cke-saved-href="http://jsfiddle.net/" href="http://jsfiddle.net/">JSFiddle</a>, but with a tightly integrated Python based server side component built in, accessible via a notebook interface.</p><h2>The normal way of doing things</h2><p>A typical interactive rich web application consists of a rich client implemened in Javascript that accesses a server side API from which it obtains data to display to the user. The two must be carefully designed, so that when the client requires some data, it can compose a request to the server that will identify the data that it needs.</p><p>This is in contrast to desktop GUI development, where the data model, GUI elements and application logic reside within the same process.</p><h2>The Ubiquitous Larch way</h2><p>Ubiquitous Larch notebooks (partially) smooth over the gap between server and client:</p><ul><li>server side and clent side code can reside together within the same notebook (as we will see)</li><li>Larch maintains&nbsp;an association between server side objects and the client side HTML that displays them; must of the careful API design work is taken care of</li><li>the client side code can send events to the server side, where&nbsp;Larch will route them to the correct server side callback funtions; just connect callbacks to events and handle them as they arrive</li></ul><h2>Lets demonstrate</h2><p>Lets start by displaying some simple HTML:</p>
p13
sS'notebook'
p14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p15
g2
Ntp16
Rp17
(dp18
S'code'
p19
g0
(clarch.apps.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
V# Import the Html presentation type\u000afrom larch.pres.html import Html\u000a\u000aHtml('<p>A quick demonstration that <span class="emph">HTML output</span> is rendered as expected.</p>')
p24
sS'editable'
p25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp26
Rp27
(dp28
g12
V<h2>Client side and server side together</h2><p>Lets start simple by adding some CSS. We shall do this with a CSS code block. The CSS source code will be made available as a string assigned to the variable name showed in the header of the block.</p>
p29
sg14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockSource
p30
g2
Ntp31
Rp32
(dp33
g19
g0
(clarch.apps.source_code
CSSCode
p34
g2
Ntp35
Rp36
(dp37
g19
V@import url(http://fonts.googleapis.com/css?family=Oswald:300);\u000a\u000a.title_bar {\u000a    font-family: 'Oswald', sans-serif;\u000a    font-size: 96px;\u000a    text-align: center;\u000a    text-shadow: 0 2px 4px #808080;\u000a	color: #ffffff;\u000a    background: #ffb000;\u000a    padding: 30px 10px 30px 10px;\u000a    border-bottom: 1px solid #c09600;\u000a    box-shadow: 0 5px 5px #aaaaaa;\u000a    margin-bottom: 10px;\u000a}\u000a
p38
sg25
I01
sbsS'var_name'
p39
Vdemo_css
p40
sg14
g4
sbag0
(g8
g2
Ntp41
Rp42
(dp43
g12
V<p>Now to use it:</p>
p44
sg14
g4
sbag0
(g15
g2
Ntp45
Rp46
(dp47
g19
g0
(g20
g2
Ntp48
Rp49
(dp50
g19
V# The use_css chain method makes the css specified available for use by the HTML code.\u000a# It can also use CSS obtained from a URL; just omit the 'source=' argument name.\u000a\u000aHtml('<div class="title_bar">Dynamic, interactive applications</div>').use_css(source=demo_css)
p51
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp52
Rp53
(dp54
g12
V<p>Now lets proceed with a more complete example, combining server-side Python, with client side Javascript&nbsp;and HTML. We are going to make an image compose of random dots, which can be re-generated by clicking a button.</p>
p55
sg14
g4
sbag0
(g8
g2
Ntp56
Rp57
(dp58
g12
V<p>Now, we will write some Python code that will generate the SVG diagram, followed by a simple example to test it:</p>
p59
sg14
g4
sbag0
(g15
g2
Ntp60
Rp61
(dp62
g19
g0
(g20
g2
Ntp63
Rp64
(dp65
g19
Vimport random\u000afrom larch.pres.html import Html\u000a\u000a# Function to generate a colour for a given co-ordinate\u000adef colour(x, y):\u000a    red = (x/500.0) * 100.0 + 100.0\u000a    grn = (y/500.0) * 100.0 + 100.0\u000a    blu = 200.0\u000a    return 'rgba({0}, {1}, {2}, 0.5)'.format(int(red), int(grn), int(blu))\u000a\u000a# Function to create a circle, with a given centre and radius\u000adef circle(x, y, r):\u000a    return Html('<circle cx="{0}" cy="{1}" r="{2}" fill="{3}" stroke="{3}" stroke-width="1"/>'.format(x, y, r, colour(x, y)))\u000a\u000a# Function to create an SVG element. The size and contents are specified\u000adef svg(width, height, contents):\u000a    # Html(*([a, b, c] + xs + [p, q, r])) is ugly: use the extend() and append() chain methods to get around this:\u000a    return Html('<svg width="{0}" height="{1}">'.format(width, height)).extend(contents).append('</svg>')\u000a\u000a# Function generate a randomly positioned circle. As arguments, it takes the centre of the distribution, standard deviation and radius\u000adef random_circle(mu_x, mu_y, sigma, radius):\u000a    return circle(random.gauss(mu_x, sigma), random.gauss(mu_y, sigma), radius)\u000a\u000a# Function to generate a random dots diagram, of a given size, sigma and number if circles\u000adef random_dots(width, height, sigma, radius, N):\u000a    return svg(width, height, [random_circle(width*0.5, height*0.5, sigma, radius)   for i in xrange(N)])\u000a\u000a\u000arandom_dots(500.0, 500.0, 60.0, 4.0, 2048)
p66
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp67
Rp68
(dp69
g12
V<p>Good; that works as expected.</p><p>Now for the re-roll button. We need some Javascript for this. The Javascript code must respond to click events and notify the server side of the action, so that it can re-create the diagram.</p>
p70
sg14
g4
sbag0
(g30
g2
Ntp71
Rp72
(dp73
g19
g0
(clarch.apps.source_code
JSCode
p74
g2
Ntp75
Rp76
(dp77
g19
Vfunction initReRollButton(node) {\u000a    // node is the DOM element that we are to initialise.\u000a    \u000a    // Use jQuery to make the button pretty and hook up the click event:\u000a    var button = $(node).button();\u000a    button.click(function(event, ui) {\u000a        // Use the larch.postEvent function to send the 're-roll' event from the DOM element node.\u000a        // null is the event data; there isn't any since there is no information to send\u000a        larch.postEvent(node, "re-roll", null);\u000a    });\u000a}
p78
sg25
I01
sbsg39
Vreroll_button_js
p79
sg14
g4
sbag0
(g8
g2
Ntp80
Rp81
(dp82
g12
V<p>Now, we implemented the server side Python code, that will display a re-rollable diagram:</p>
p83
sg14
g4
sbag0
(g15
g2
Ntp84
Rp85
(dp86
g19
g0
(g20
g2
Ntp87
Rp88
(dp89
g19
Vfrom larch.live import LiveValue\u000a\u000a\u000a# Generalise the title bar into a function\u000adef make_title_bar(text, css_class='title_bar', css_source=demo_css):\u000a    return Html('<div class="{1}">{0}</div>'.format(text, css_class)).use_css(source=css_source)\u000a\u000a\u000a# Create a function that will create our demo\u000adef re_rollable_demo(title):\u000a    # LiveValue objects are wrappers that contain a value. They have the useful property that when the value that they contain is changed, the visual representation will be automatically be updated.\u000a    diagram_live = LiveValue(random_dots(500.0, 500.0, 60.0, 4.0, 2048))\u000a    \u000a    # This function is invoked in response to receiving a 're-roll' event from the client. It is connected below.\u000a    def on_reroll(event):\u000a        # Set the value of 'diagram_live' to be a new dots diagram\u000a        diagram_live.value = random_dots(500.0, 500.0, 60.0, 4.0, 2048)\u000a    \u000a    # Create the button. The js_function_call method initialises the DOM element created by the Html presentation\u000a    # object using a Javascript function that is named by the first argument - 'initReRollButton' in this case,\u000a    # see the Javascript code above. Subsequent arguments to js_function_call will be passed over too.\u000a    button = Html('<button>Click to re-roll</button>').js_function_call('initReRollButton')\u000a    # Attach an event handler to the 're-roll' event. The event is sent from the Javascript code above, using\u000a    # the client-side larch.postEvent method. Any re-roll events originating from the DOM nodes created by this\u000a    # presentation object will be handled by the attached handler function\u000a    button = button.with_event_handler('re-roll', on_reroll)\u000a    # Use the use_js method - whose form and purpose are analogous to use_css seen earlier - to make the Javascript\u000a    # code above available for use.\u000a    button = button.use_js(source=reroll_button_js)\u000a    \u000a    # Arrange the title bar, diagram and button\u000a    return Html(make_title_bar(title), '<div>', diagram_live, '<br>', button, '</div>')\u000a\u000a# Now, for a demo\u000are_rollable_demo('Re-rollable dots')
p90
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp91
Rp92
(dp93
g12
V<p>We can create another diagram, by calling the <code>re_rollable_demo</code> function&nbsp;again:</p>
p94
sg14
g4
sbag0
(g15
g2
Ntp95
Rp96
(dp97
g19
g0
(g20
g2
Ntp98
Rp99
(dp100
g19
Vre_rollable_demo('More re-rollable dots')
p101
sg25
I01
sbsg14
g4
sbag0
(g8
g2
Ntp102
Rp103
(dp104
g12
V<p>Notice that the diagrams are independent of one another. Clicking the button only updates its corresponding diagram; the other diagram is left alone.</p><p>Notice the lack of element IDs or use of CSS classes. Ubiquitous Larch builds the page in such a way that it is able to associate elements on the client with the relevant objects on the server, for the purpose of ensuring that events arrive at&nbsp;the correct place.</p>
p105
sg14
g4
sbag0
(g30
g2
Ntp106
Rp107
(dp108
g19
g0
(g34
g2
Ntp109
Rp110
(dp111
g19
V@import url(http://fonts.googleapis.com/css?family=Oswald:300);\u000a\u000a.final_title_bar {\u000a    font-family: 'Oswald', sans-serif;\u000a    font-size: 64px;\u000a    text-align: center;\u000a    text-shadow: 0 2px 4px #204000;\u000a	color: #ffffff;\u000a    background: #388000;\u000a    padding: 30px 10px 30px 10px;\u000a    border-bottom: 1px solid #c09600;\u000a    box-shadow: 0 5px 5px #aaaaaa;\u000a    margin-bottom: 10px;\u000a}\u000a
p112
sg25
I01
sbsg39
Vfinal_css
p113
sg14
g4
sbag0
(g15
g2
Ntp114
Rp115
(dp116
g19
g0
(g20
g2
Ntp117
Rp118
(dp119
g19
Vmake_title_bar('The result: client and server side objects that just work together, with a simple declarative API.', 'final_title_bar', final_css)
p120
sg25
I01
sbsg14
g4
sbasb.