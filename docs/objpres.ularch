ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockText
p8
g2
Ntp9
Rp10
(dp11
S'text'
p12
V<h1 style="text-align:center">Visual, interactive Python objects via type coercion</h1><p>With Ubiquituos Larch, Python objects can be presented using type coercion. You can define&nbsp;a visual, interactive presentation for an object using a similar approach to that used to define a string/textual representation by implementing a&nbsp;<code>__str__</code> method.</p><p>Normal Python objects can be presented by embedding them within presentation descriptions, built from presentation types. They are automatically converted for you. If Ubiquitous Larch is notified of a modification to an object's state, it will update it's&nbsp;in-browser representations automatically.</p><p>The conversion process is recursive. As a consequence, you can implement visual, interactive components as a collection of live Python objects.</p><p><br></p><h2>MVC for free</h2><p>The most common design pattern for implementing GUI based applications is Model-View-Controller. Typical implementations require the use of quite a lot of boilerplate code for creating, updating and destroying views of objects in response to state changes. The type-coercion driven system used in Larch handles much of this for you.</p>
p13
sS'notebook'
p14
g4
sbag0
(g8
g2
Ntp15
Rp16
(dp17
g12
V<h2>In context: string/textual representations using <code>__str__</code></h2><p>Recall that by default, an object is converted to a string using its type and its address:<br></p>
p18
sg14
g4
sbag0
(clarch.apps.notebook.notebook
NotebookBlockCode
p19
g2
Ntp20
Rp21
(dp22
S'code'
p23
g0
(clarch.apps.source_code
PythonCode
p24
g2
Ntp25
Rp26
(dp27
g23
Vclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000astr(Point(2.0, 5.0))
p28
sS'editable'
p29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp30
Rp31
(dp32
g12
V<p>We can customise this by defining a <code>__str__</code> method:</p>
p33
sg14
g4
sbag0
(g19
g2
Ntp34
Rp35
(dp36
g23
g0
(g24
g2
Ntp37
Rp38
(dp39
g23
Vclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000a    def __str__(self):\u000a        return '[{0} {1}]'.format(self.x, self.y)\u000a        \u000astr(Point(2.0, 5.0))
p40
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp41
Rp42
(dp43
g12
V<p>This can now be used in more complex, composite objects. The <code>__str__</code> method of the LineSegment class in turn converts the points to strings, and joins them together:</p>
p44
sg14
g4
sbag0
(g19
g2
Ntp45
Rp46
(dp47
g23
g0
(g24
g2
Ntp48
Rp49
(dp50
g23
Vclass LineSegment (object):\u000a    def __init__(self, a, b):\u000a        self.a, self.b = a, b\u000a        \u000a    def __str__(self):\u000a        return '{0} -> {1}'.format(self.a, self.b)\u000a\u000astr(LineSegment(Point(1.0, 2.0), Point(5.0, 8.0)))
p51
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp52
Rp53
(dp54
g12
V<h2>Visual representations using <code>__present__</code></h2><p>Within Ubiquitous Larch, the <code>__present__</code> method provides similar functionaltiy, except that you can use HTML markup to control the layout of your presentation. Back to our <code>Point</code> example:</p>
p55
sg14
g4
sbag0
(g19
g2
Ntp56
Rp57
(dp58
g23
g0
(g24
g2
Ntp59
Rp60
(dp61
g23
V# We need to import the Html presentation type, as __present__ must return presentation types.\u000afrom larch.pres.html import Html\u000a\u000aclass Point (object):\u000a    def __init__(self, x, y):\u000a        self.x, self.y = x, y\u000a        \u000a    def __str__(self):\u000a        return '[{0} {1}]'.format(self.x, self.y)\u000a    \u000a    def __present__(self, fragment):\u000a        # The [ and ] character surrounding the point co-ordinates.\u000a        open_bracket = '<span style="font-size: 3em">[</span>'\u000a        close_bracket = '<span style="font-size: 3em">]</span>'\u000a        # Arrange the X and Y co-ordinates vertically in a table, surround with the brackets\u000a        return Html(open_bracket,\u000a                    '<table style="border: 1px solid #e0e0e0; display: inline-table;"><tbody><tr><td>',\u000a                    self.x, '</td></tr><tr><td>', self.y, '</td></tr></tbody></table>',\u000a                    close_bracket)\u000a        \u000aPoint(2.0, 5.0)
p62
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp63
Rp64
(dp65
g12
V<h2>Composeability</h2><p>Presentations are also composeable, as demonstrated with a visual version of the line segment example:</p>
p66
sg14
g4
sbag0
(g19
g2
Ntp67
Rp68
(dp69
g23
g0
(g24
g2
Ntp70
Rp71
(dp72
g23
Vclass LineSegment (object):\u000a    def __init__(self, a, b):\u000a        self.a, self.b = a, b\u000a        \u000a    def __str__(self):\u000a        return '{0} -> {1}'.format(self.a, self.b)\u000a    \u000a    def __present__(self, fragment):\u000a        return Html(self.a, '<span style="font-weight: bold;">', Html.escape_str('->'), '</span>', self.b)\u000a\u000aLineSegment(Point(1.0, 2.0), Point(5.0, 8.0))
p73
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp74
Rp75
(dp76
g12
V<p>It doesn't look&nbsp;great, but you get the point; the point objects were passed to the <code>Html</code> presentation type. Larch automatically constructed views of these objects and incorporated them within&nbsp;the view of the line segment.</p>
p77
sg14
g4
sbag0
(g8
g2
Ntp78
Rp79
(dp80
g12
V<h2>Interactive Python objects</h2><p>The content generated by a <code>__present__</code> method does not have to be static; it can be interactive too. In the next example, we will add controls, along with interactive updates:<br></p>
p81
sg14
g4
sbag0
(g19
g2
Ntp82
Rp83
(dp84
g23
g0
(g24
g2
Ntp85
Rp86
(dp87
g23
V# We must import the IncrementalValueMonitor class.\u000a# Incremental monitors are used to inform Larch when the state of an\u000a# object has changed, so that Larch may schedule a refresh.\u000afrom larch.incremental import IncrementalValueMonitor\u000a\u000a# We would also like to use button conrols in this example.\u000afrom larch.controls import button\u000a\u000a\u000aclass Counter (object):\u000a    def __init__(self):\u000a        self.value = 0\u000a        # The incremental value monitor helps Larch track the state of this object\u000a        self.__incr = IncrementalValueMonitor()\u000a        \u000a        \u000a    def increment(self, event):\u000a        self.value += 1\u000a        # We have changed the state of this object; inform the monitor\u000a        self.__incr.on_changed()\u000a        \u000a    def decrement(self, event):\u000a        self.value -= 1\u000a        # We have changed the state of this object; inform the monitor\u000a        self.__incr.on_changed()\u000a        \u000a    def __present__(self, fragment):\u000a        # We are using the state of this object to construct the presentation; inform the incremental monitor of an access:\u000a        self.__incr.on_access()\u000a        \u000a        # Decrement button, label is '<', invoke the decrement method when clicked\u000a        dec_button = button.button('<', self.decrement)\u000a        # Increment button, label is '>', invoke the increment method when clicked\u000a        inc_button = button.button('>', self.increment)\u000a        \u000a        return Html(dec_button, '<span style="margin-left: 1em; margin-right: 1em">', self.value, '</span>', inc_button)\u000a\u000a\u000aCounter()
p88
sg29
I01
sbsg14
g4
sbag0
(g8
g2
Ntp89
Rp90
(dp91
g12
V<p>The buttons are arranged to surround the value. When they are clicked, the <code>decrement</code>&nbsp;or <code>increment</code>&nbsp;methods are invoked. These in turn modify the value and inform the incremental monitor. U-Larch maintains an association between the object (a Counter in this case) and its visual representation. When it is notified of a change to the object's state, it re-invokes&nbsp;<code>__present__</code>&nbsp;in order to build a new presentation of the counter, which is inserted into the DOM in place of the old one. As a consequence, you can now write interactive browser applications in Python.</p>
p92
sg14
g4
sbag0
(g8
g2
Ntp93
Rp94
(dp95
g12
V<h2>Ubiquitous Larch is interactive Python objects all the way down</h2><p>The viability of this approach is demonstrated by the fact that everything that you have seen in Ubiquitous&nbsp;Larch so far is presented in this way; this notebook, its blocks, the front page that displays the list of documents, and the console.</p><p>Larch can be said to operate in a similar fashion to Smalltalk, in that it operates as interactive live objects. The main differences are:</p><ul><li>Python language instead of Smalltalk</li><li>A web browser as a renderer and GUI toolkit rather than the window oriented toolkits used in most Smalltalk systems</li><li>Type ceorcion based presentation provides MVC style functionality for free</li></ul>
p96
sg14
g4
sbasb.