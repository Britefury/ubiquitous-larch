ccopy_reg
_reconstructor
p0
(clarch.worksheet.worksheet
Worksheet
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.worksheet.worksheet
WorksheetBlockText
p8
g2
Ntp9
Rp10
(dp11
S'worksheet'
p12
g4
sS'text'
p13
V<h1 style="text-align:center">Client side and server side all in one</h1><p><br></p><p>A worksheet can function a bit like a <a data-cke-saved-href="http://jsfiddle.net/" href="http://jsfiddle.net/">JSFiddle</a>, but with a tightly integrated Python based server side component built in, accessible via a notebook interface.</p><h2>The normal way of doing things</h2><p>A typical interactive rich web application consists of a rich client implemened in Javascript that accesses a server side API from which it obtains data to display to the user. The two must be carefully designed, so that when the client requires some data, it can compose a request to the server that will identify the data that it needs.</p><p>This is in contrast to desktop GUI development, where the data model, GUI elements and application logic reside within the same process.</p><h2>The Ubiquitous Larch way</h2><p>Ubiquitous Larch worksheets (partially) smooth over the gap between server and client:</p><ul><li>server side and clent side code can reside together within the same worksheet (as we will see)</li><li>Larch maintains&nbsp;an association between server side objects and the client side HTML that displays them; must of the careful API design work is taken care of</li><li>the client side code can send events to the server side, where&nbsp;Larch will route them to the correct server side callback funtions; just connect callbacks to events and handle them as they arrive</li></ul><h2>Lets demonstrate</h2><p>Lets start by displaying some simple HTML:</p>
p14
sbag0
(clarch.worksheet.worksheet
WorksheetBlockCode
p15
g2
Ntp16
Rp17
(dp18
g12
g4
sS'code'
p19
g0
(clarch.source_code
PythonCode
p20
g2
Ntp21
Rp22
(dp23
g19
V# Import the Html presentation type\u000afrom britefury.pres.html import Html\u000a\u000aHtml('<p>A quick demonstration that <span class="emph">HTML output</span> is rendered as expected.</p>')
p24
sS'editable'
p25
I01
sbsbag0
(g8
g2
Ntp26
Rp27
(dp28
g12
g4
sg13
V<h2>Client side and server side together</h2><p>Lets start simple by adding some CSS. We shall do this with a CSS code block. The CSS source code will be made available as a string assigned to the variable name showed in the header of the block.</p>
p29
sbag0
(clarch.worksheet.worksheet
WorksheetBlockSource
p30
g2
Ntp31
Rp32
(dp33
g12
g4
sg19
g0
(clarch.source_code
CSSCode
p34
g2
Ntp35
Rp36
(dp37
g19
V@import url(http://fonts.googleapis.com/css?family=Oswald:300);\u000a\u000a.title_bar {\u000a    font-family: 'Oswald', sans-serif;\u000a    font-size: 96px;\u000a    text-align: center;\u000a    text-shadow: 0 2px 4px #808080;\u000a	color: #ffffff;\u000a    background: #ffb000;\u000a    padding: 30px 10px 30px 10px;\u000a    border-bottom: 1px solid #c09600;\u000a    box-shadow: 0 5px 5px #aaaaaa;\u000a    margin-bottom: 10px;\u000a}\u000a
p38
sg25
I01
sbsS'var_name'
p39
Vdemo_css
p40
sbag0
(g8
g2
Ntp41
Rp42
(dp43
g12
g4
sg13
V<p>Now to use it:</p>
p44
sbag0
(g15
g2
Ntp45
Rp46
(dp47
g12
g4
sg19
g0
(g20
g2
Ntp48
Rp49
(dp50
g19
V# The use_css chain method makes the css specified available for use by the HTML code.\u000a# It can also use CSS obtained from a URL; just omit the 'source=' argument name.\u000a\u000aHtml('<div class="title_bar">Dynamic, interactive applications</div>').use_css(source=demo_css)
p51
sg25
I01
sbsbag0
(g8
g2
Ntp52
Rp53
(dp54
g12
g4
sg13
V<p>Now lets proceed with a more complete example, combining server-side Python, with client side Javascript, CSS and HTML. We are going to make an image compose of random dots, which can be re-generated by clicking a button.</p><p>First, we need some CSS that will style our SVG diagram:</p>
p55
sbag0
(g30
g2
Ntp56
Rp57
(dp58
g12
g4
sg19
g0
(g34
g2
Ntp59
Rp60
(dp61
g19
V.graph circle {\u000a    fill: #a00000;\u000a}\u000a\u000a.graph {\u000a    border: 1px solid #e0e0e0;\u000a}
p62
sg25
I01
sbsg39
Vgraph_css
p63
sbag0
(g8
g2
Ntp64
Rp65
(dp66
g12
g4
sg13
V<p>Now, we will write some Python code that will generate the SVG diagram, followed by a simple example to test it:</p>
p67
sbag0
(g15
g2
Ntp68
Rp69
(dp70
g12
g4
sg19
g0
(g20
g2
Ntp71
Rp72
(dp73
g19
Vimport random\u000a\u000a# Function to create a circle, with a given centre and radius\u000adef circle(x, y, r):\u000a    return Html('<circle cx="{0}" cy="{1}" r="{2}"/>'.format(x, y, r))\u000a\u000a# Function to create an SVG element. The size, CSS class and contents are specified\u000adef svg(width, height, css_class, contents):\u000a    # Html(*([a, b, c] + xs + [p, q, r])) is ugly: use the extend() and append() chain methods to get around this:\u000a    return Html('<svg width="{0}" height="{1}" class="{2}">'.format(width, height, css_class)).extend(contents).append('</svg>')\u000a\u000a# Function generate a randomly positioned circle. As arguments, it takes the centre of the distribution, standard deviation and radius\u000adef random_circle(mu_x, mu_y, sigma, radius):\u000a    return circle(random.gauss(mu_x, sigma), random.gauss(mu_y, sigma), radius)\u000a\u000a# Function to generate a random dots diagram, of a given size, CSS class, sigma and \u000adef random_dots(width, height, css_class, sigma, radius, N):\u000a	return svg(width, height, css_class, [random_circle(width*0.5, height*0.5, sigma, radius)   for i in xrange(N)]).use_css(source=graph_css)\u000a\u000a\u000arandom_dots(500.0, 500.0, "graph", 60.0, 4.0, 768)
p74
sg25
I01
sbsbag0
(g8
g2
Ntp75
Rp76
(dp77
g12
g4
sg13
V<p>Good; that works as expected.</p><p>Now for the re-roll button. We need some Javascript for this. The Javascript code must respond to click events and notify the server side of the action, so that it can re-create the diagram.</p>
p78
sbag0
(g30
g2
Ntp79
Rp80
(dp81
g12
g4
sg19
g0
(clarch.source_code
JSCode
p82
g2
Ntp83
Rp84
(dp85
g19
Vfunction initReRollButton(node) {\u000a    // node is the DOM element that we are to initialise.\u000a    \u000a    // Use jQuery to make the button pretty and hook up the click event:\u000a    var button = $(node).button();\u000a    button.click(function(event, ui) {\u000a        // Use the larch.postEvent function to send the 're-roll' event from the DOM element node.\u000a        // null is the event data; there isn't any since there is no information to send\u000a        larch.postEvent(node, "re-roll", null);\u000a    });\u000a}
p86
sg25
I01
sbsg39
Vreroll_button_js
p87
sbag0
(g8
g2
Ntp88
Rp89
(dp90
g12
g4
sg13
V<p>Now, we implemented the server side Python code, that will display a re-rollable diagram:</p>
p91
sbag0
(g15
g2
Ntp92
Rp93
(dp94
g12
g4
sg19
g0
(g20
g2
Ntp95
Rp96
(dp97
g19
Vfrom britefury.live import LiveValue\u000a\u000a\u000a# Generalise the title bar into a function\u000adef make_title_bar(text, css_class='title_bar', css_source=demo_css):\u000a    return Html('<div class="{1}">{0}</div>'.format(text, css_class)).use_css(source=css_source)\u000a\u000a\u000a# Create a function that will create our demo\u000adef re_rollable_demo(title):\u000a    # LiveValue objects are wrappers that contain a value. They have the useful property that when the value that they contain is changed, the visual representation will be automatically be updated.\u000a    diagram_live = LiveValue(random_dots(500.0, 500.0, "graph", 60.0, 4.0, 768))\u000a    \u000a    # This function is invoked in response to receiving a 're-roll' event from the client. It is connected below.\u000a    def on_reroll(event_name, event_data):\u000a        # Set the value of 'diagram_live' to be a new dots diagram\u000a        diagram_live.value = random_dots(500.0, 500.0, "graph", 60.0, 4.0, 768)\u000a    \u000a    # Create the button. The js_function_call method initialises the DOM element created by the Html presentation\u000a    # object using a Javascript function that is named by the first argument - 'initReRollButton' in this case,\u000a    # see the Javascript code above. Subsequent arguments to js_function_call will be passed over too.\u000a    button = Html('<button>Click to re-roll</button>').js_function_call('initReRollButton')\u000a    # Attach an event handler to the 're-roll' event. The event is sent from the Javascript code above, using\u000a    # the client-side larch.postEvent method. Any re-roll events originating from the DOM nodes created by this\u000a    # presentation object will be handled by the attached handler function\u000a    button = button.with_event_handler('re-roll', on_reroll)\u000a    # Use the use_js method - whose form and purpose are analogous to use_css seen earlier - to make the Javascript\u000a    # code above available for use.\u000a    button = button.use_js(source=reroll_button_js)\u000a    \u000a    # Arrange the title bar, diagram and button\u000a    return Html(make_title_bar(title), '<div>', diagram_live, '<br>', button, '</div>')\u000a\u000a# Now, for a demo\u000are_rollable_demo('Re-rollable dots')
p98
sg25
I01
sbsbag0
(g8
g2
Ntp99
Rp100
(dp101
g12
g4
sg13
V<p>We can create another diagram, by calling the <code>re_rollable_demo</code> function&nbsp;again:</p>
p102
sbag0
(g15
g2
Ntp103
Rp104
(dp105
g12
g4
sg19
g0
(g20
g2
Ntp106
Rp107
(dp108
g19
Vre_rollable_demo('More re-rollable dots')
p109
sg25
I01
sbsbag0
(g8
g2
Ntp110
Rp111
(dp112
g12
g4
sg13
V<p>Notice that the diagrams are independent of one another. Clicking the button only updates its corresponding diagram; the other diagram is left alone.</p><p>Notice the lack of element IDs or use of CSS classes. Ubiquitous Larch builds the page in such a way that it is able to associate elements on the client with the relevant objects on the server, for the purpose of ensuring that events arrive at&nbsp;the correct place.</p>
p113
sbag0
(g30
g2
Ntp114
Rp115
(dp116
g12
g4
sg19
g0
(g34
g2
Ntp117
Rp118
(dp119
g19
V@import url(http://fonts.googleapis.com/css?family=Oswald:300);\u000a\u000a.final_title_bar {\u000a    font-family: 'Oswald', sans-serif;\u000a    font-size: 64px;\u000a    text-align: center;\u000a    text-shadow: 0 2px 4px #204000;\u000a	color: #ffffff;\u000a    background: #388000;\u000a    padding: 30px 10px 30px 10px;\u000a    border-bottom: 1px solid #c09600;\u000a    box-shadow: 0 5px 5px #aaaaaa;\u000a    margin-bottom: 10px;\u000a}\u000a
p120
sg25
I01
sbsg39
Vfinal_css
p121
sbag0
(g15
g2
Ntp122
Rp123
(dp124
g12
g4
sg19
g0
(g20
g2
Ntp125
Rp126
(dp127
g19
Vmake_title_bar('The result: client and server side objects that just work together, with a simple declarative API.', 'final_title_bar', final_css)
p128
sg25
I01
sbsbasb.