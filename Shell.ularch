ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockCode
p8
g2
Ntp9
Rp10
(dp11
S'code'
p12
g0
(clarch.apps.source_code
PythonCode
p13
g2
Ntp14
Rp15
(dp16
g12
Vimport sys\u000aimport time\u000afrom subprocess import PIPE, Popen\u000afrom threading  import Thread\u000afrom larch.apps.console import console\u000afrom larch.apps import source_code\u000a\u000atry:\u000a    from Queue import Queue, Empty\u000aexcept ImportError:\u000a    from queue import Queue, Empty  # python 3.x\u000a\u000a    \u000aON_POSIX = 'posix' in sys.builtin_module_names    \u000a\u000a\u000a\u000a\u000a\u000aclass AsyncQueue (object):\u000a    def __init__(self, stream):\u000a        def enqueue_output(out, queue):\u000a            for line in iter(out.readline, b''):\u000a                queue.put(line)\u000a            out.close()\u000a    \u000a        self.q = Queue()\u000a        t = Thread(target=enqueue_output, args=(stream, self.q))\u000a        t.daemon = True # thread dies with the program\u000a        t.start()\u000a        \u000a        \u000a    def read_into(self, dest_stream):\u000a        while True:\u000a            try:\u000a                line = self.q.get(timeout=.2)\u000a            except Empty:\u000a                break\u000a            else: # got line\u000a                dest_stream.write(line)\u000a        \u000a    \u000a\u000a\u000aclass ShellConsole (console.AbstractConsole):\u000a    def __init__(self, code=''):\u000a        super(ShellConsole, self).__init__(code)\u000a        \u000a            \u000a        cmd = '/bin/sh'   if ON_POSIX   else 'cmd'\u000a        \u000a        self.shell = Popen([cmd], stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=1, close_fds=ON_POSIX)\u000a        \u000a        self.q_out = AsyncQueue(self.shell.stdout)\u000a        self.q_err = AsyncQueue(self.shell.stderr)\u000a        \u000a        \u000a    def _source_text_to_code_object(self, source_text):\u000a        return source_code.ShellCode(source_text)\u000a\u000a    def _get_result_of_executing_code(self, code):\u000a        self.shell.stdin.write(code.source_text + '\u005cn')\u000a        self.shell.stdin.flush()\u000a        \u000a        streams = source_code.InterleavedTextOutStream(source_code._stream_style_map)\u000a        out = streams.named_stream('stdout')\u000a        err = streams.named_stream('stderr')\u000a        \u000a        self.q_out.read_into(out)\u000a        self.q_err.read_into(err)\u000a        \u000a        return streams\u000a\u000a\u000a    def _get_console_preamble_text(self):\u000a        return 'Command shell'\u000a        \u000aShellConsole()
p17
sS'editable'
p18
I01
sbsS'notebook'
p19
g4
sbasb.