ccopy_reg
_reconstructor
p0
(clarch.apps.notebook.notebook
Notebook
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'blocks'
p6
(lp7
g0
(clarch.apps.notebook.notebook
NotebookBlockCode
p8
g2
Ntp9
Rp10
(dp11
S'code'
p12
g0
(clarch.apps.source_code
PythonCode
p13
g2
Ntp14
Rp15
(dp16
g12
Vimport sys\u000aimport time\u000afrom subprocess import PIPE, Popen\u000afrom threading  import Thread\u000afrom larch.apps.console import console\u000afrom larch.apps import source_code\u000a\u000atry:\u000a    from Queue import Queue, Empty\u000aexcept ImportError:\u000a    from queue import Queue, Empty  # python 3.x\u000a\u000a    \u000aON_POSIX = 'posix' in sys.builtin_module_names    \u000a\u000a    \u000aclass ShellConsole (console.AbstractConsole):\u000a    def __init__(self, code=''):\u000a        super(ShellConsole, self).__init__(code)\u000a        \u000a        def enqueue_output(out, queue):\u000a            for line in iter(out.readline, b''):\u000a                queue.put(line)\u000a            out.close()\u000a            \u000a        cmd = '/bin/sh'   if ON_POSIX   else 'cmd'\u000a        \u000a        self.shell = Popen([cmd], stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=1, close_fds=ON_POSIX)\u000a        self.q_out = Queue()\u000a        self.q_err = Queue()\u000a        t_out = Thread(target=enqueue_output, args=(self.shell.stdout, self.q_out))\u000a        t_out.daemon = True # thread dies with the program\u000a        t_out.start()\u000a        t_err = Thread(target=enqueue_output, args=(self.shell.stderr, self.q_err))\u000a        t_err.daemon = True # thread dies with the program\u000a        t_err.start()\u000a        \u000a        \u000a    def _source_text_to_code_object(self, source_text):\u000a        return source_code.ShellCode(source_text)\u000a\u000a    def _get_result_of_executing_code(self, code):\u000a        self.shell.stdin.write(code.source_text)\u000a        \u000a        streams = source_code.InterleavedTextOutStream(source_code._stream_style_map)\u000a        out = streams.named_stream('stdout')\u000a        err = streams.named_stream('stderr')\u000a        \u000a        # read line without blocking\u000a        while True:\u000a            try:\u000a                line = self.q_out.get(timeout=.1)\u000a            except Empty:\u000a                break\u000a            else: # got line\u000a                out.write(line)\u000a            \u000a        # read line without blocking\u000a        while True:\u000a            try:\u000a                line = self.q_err.get(timeout=.1)\u000a            except Empty:\u000a                break\u000a            else: # got line\u000a                err.write(line)\u000a            \u000a            \u000a        return streams\u000a\u000a\u000a    def _get_console_preamble_text(self):\u000a        return 'Command shell'\u000a        \u000aShellConsole()
p17
sS'editable'
p18
I01
sbsS'notebook'
p19
g4
sbasb.